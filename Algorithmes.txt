// freopen(x, "r", stdin)

#define node tuple<int,int>
#define pi 3.14159265359
#define log(x , y) log10(y)/log10(x)
#define left p<<1 , l , (l+r)>>1
#define right p<<1|1 , ((l+r)>>1)+1 , r
#define coutt(x)     printf("%d\n", x);
#define binary(x,n)     std::string str = std::bitset<n>(x).to_string()
#define point complex <int>

printf("%d %d\n%d %d\n", j, i, n - j + 1, m - i + 1);
///////////////////////////////////////////////////////////////////////////////////////////////////
                                                                        Math
                                                                     ----------
(( GCD & LCM )):
****************
   1- if  a=0  ==>  GCD(a.b) = 0

   2- Euclid's : if we want the gcd of (a , b) and we can write a/b = c , a%b = d then GCD(a,b) = GCD(b,d)  and the O(max(a,b))
      code : int GCD(int a , int b){
            if(b == 0)  return a;
            else  return GCD(b,a%b);
      }
   
   3- gcd function with O(min(a,b));
   code : int gcd(int a , int b){
         int mini = min(a,b) , ans;
         for(int i=mini;i>0;i--){
            if(a%i == 0  &&  b%i == 0){
               ans = i ;
               return ans;
            }
         }
   }
   ll lcm(ll a, ll b){
        return a / __gcd(a,b) * b; 
    }   
   4- GCD(m.a,m.b) = m * GCD(a,b)
   5- GCD(a/m,b/m) = GCD(a,b)/m
   6- GCD(a,b) * LCM(a,b) = a * b
   7- GCD(0,0) = 0 = LCM(0,0)
   8- GCD(a,b,c) = GCD(a,GCD(b,c))
   9- if GCD(a,m) = 1   ==> GCD(m,a*b) = GCD(m,b)
   10- GCD(a,b) = d  ==> GCD(a/d,b/d) = 1
   11- GCD(a,b) = GCD(b,a%b)
   12- GCD(a,a+1) = 1
   13- Find three distinct positive integers a, b, c such that a+b+c=n and gcd(a,b)=c, where gcd(x,y)
      ll n ;
        cin>>n;
        if(n%2 == 0){
            cout<<n-3<<" "<<2<<" "<<1<<Endl;
        }
        else{
            for(ll i=2;i<n/2;i++){
                if(__gcd(n-i-1,i) == 1){
                    cout<<n-i-1<<" "<<i<<" "<<1<<endl;
                    break;
                }
            }
        }
///////////////////////////////////////////////////////////////////////////////////////////////////

(( Prime )):
************
1- sieve : 
    int isPrime[1000001];
    void sieve(){
        for(int i=1; i<=1000000; i++){
            isPrime[i]=1;
        }
        isPrime[1]=0;
        for(int i=1; i<=1000; i++){
            if(isPrime[i]==1){
                for(int j=i*i; j<=1000000; j+=i)
                    isPrime[j]=0;
            }
        }
    }
2- Nive Approach : O(n)
   void checkPrime(int n){
      int count = 0 ;
      for(int i=1;i<=n;i++)
         if(n%i == 0)   
            count++;
      if(count == 2)
         cout<<"N is prime"<<endl;
      else
         cout<<"N is no't Prime"<<endl;
   }

3- Nive Approach : O(sqrt(n))
   void checkPrime(int n){
      int count = 0 ;
      for(int i=1;i*i<=n;i++){
         if(n%i == 0){
            if(i*i == n)   count++;
            else           count+=2;
         }
      }
      if(count == 2)
         cout<<"N is prime"<<endl;
      else
         cout<<"N is no't Prime"<<endl;
   }

///////////////////////////////////////////////////////////////////////////////////////////////////

(( modulo )) : 
**************
         *               *
   1- (a + b)%c  =  (a%c + b%c)%c
   2- ll MOD = 1e9 + 7;
      ll bigMod(ll x,ll y){
         if (y == 0)return 1;
         if (y == 1)return x;
         ll res = bigMod(x , y / 2LL);
         res *= res;
         res %= MOD;
         if (y % 2){
            res *= x;
            res %= MOD;
         }
         return res;
      }

///////////////////////////////////////////////////////////////////////////////////////////////////
((Fast Power)) : 
****************
ll fastpow(ll a,ll n){
    if(!n)
        return 1;
    ll mul = fastpow(a,n/2);
    mul = (mul*mul)%MOD;
    if(n&1)
        mul = (a*mul)%MOD;
    return mul;
}
///////////////////////////////////////////////////////////////////////////////////////////////////

(( Factorial )) :
*****************
   1- Factorial : O(n)
      int factorial(int n){
         return (n == 1 || n == 0) ? 1 : n * factorial(n - 1);
      }

   2- Prime Factorial :
      void primeFactorial(int n){
         while(n%2 == 0){
            n/2;
         }
         for(int i=3;i<sqrt(n);i+=2){
            while(n%i == 0){
               cout<<i<<" ";
               n/=i;
            }
         }
         if(n > 2)   cout<<n;
      }

///////////////////////////////////////////////////////////////////////////////////////////////////

((Divisors of number)):
***********************

set<int> divisors;

void getDivisors(int n){
    for (int i = 1 ; i*i <= n ; i++){
        if(n%i==0){
            int x = n/i;
            divisors.insert(i);
            if(x!=i) divisors.insert(x);
        }
    }
}


((Divisors using sieve for 1->n number)):
******************************************
vector<vector<int>> allDivisors;

void getDivisorsToN(int n){
    for(int i=1 ; i<n ; i++)
        for(int j=i ; j<n ; j+=i)
            allDivisors[j].push_back(i);
}

///////////////////////////////////////////////////////////////////////////////////////////////////

((Combinatorics)):
*****************

const int N = 2020;
const int Mod = 1e9 + 7;
 
int Inv[N];
int Fact[N];
int iFact[N];
 
void add_self(int& x, int y)
{
    if((x += y) >= Mod) x -= Mod;
}
 
int add(int x, int y)
{
    return add_self(x, y), x;
}
 
void sub_self(int& x, int y)
{
    if((x -= y) < 0)    x += Mod;
}
 
int sub(int x, int y)
{
    return sub_self(x, y), x;
}
 
int mul(int x, int y)
{
    return (long long) x * y % Mod;
}
 
int C(int n, int r)
{
    if(n < 0 || r < 0 || n < r) return 0;
    return mul(Fact[n], mul(iFact[r], iFact[n - r]));
}
 
int fp(int x, int y)
{
    int Res = 1;
    for( ; y > 0; y >>= 1, x = mul(x, x))
        if(y & 1)
            Res = mul(Res, x);
    return Res;
}
 
void PreCalcMod()
{
    Inv[1] = 1;
    for(int i = 2; i < N; i++)  Inv[i] = sub(0, mul(Mod / i, Inv[Mod % i]));
 
    Fact[0] = iFact[0] = 1;
    for(int i = 1; i < N; i++)  Fact[i] = mul(i, Fact[i - 1]);
    for(int i = 1; i < N; i++)  iFact[i] = mul(Inv[i], iFact[i - 1]);
}
 
 
==========================================================================================================================================================================

                                                                           Graph
                                                                        -----------
//       R   L   D    U
int X[]={0 , 0 , 1 , -1};
int Y[]={1 , -1 , 0 , 0};
for(int i=0;i<4;i++){
    int x = + X[i];
    int y = + Y[i];
}
(( DFS )) : 
***********
    int vis[nax];
    void dfs(int i) {
        vis[i] = 1;
        for(auto v:a[i]) {
            if(!vis[v]) {
                dfs(v);
            }
        }
    }

///////////////////////////////////////////////////////////////////////////////////////////////////

(( BFS )) :
***********
    int D[nax];
    void bfs(int src) {
        for(int i=0 ; i<=n ; i++) D[i] = inf;
        queue<int> q;
        q.push(src); D[src]=0;
        while(!q.empty()){
            int u = q.front();
            q.pop();
            for(auto v:a[u]){
                if(D[v] == inf){
                    D[v] = D[u] + 1;
                    q.push(v);
                }
            }
        }
    }

///////////////////////////////////////////////////////////////////////////////////////////////////

(( DSU )) :
***********

struct DSU{
    vector<int> par, siz;
    int comp;

    DSU(int n) {
        par.assign(n, 0);
        siz.assign(n, 1);
        iota(par.begin(), par.end(), 0);
        comp=n;
    }

    int find(int x) {
        while(x!=par[x]) par[x]=par[par[x]], x=par[x];
        return x;
    }
    // merge v to u
    void merge(int u, int v) {
        int a=find(u);
        int b=find(v);
        if(a==b) return;
        comp--;
        if(siz[a]>siz[b]) swap(a, b);
        siz[b]+=siz[a];
        siz[a]=0;
        par[a]=par[b];
    }     
};

///////////////////////////////////////////////////////////////////////////////////////////////////

(( Floyd )) :
*************
vector<vector<int>> dist(1000 , vector<int> (1000));

void floyd(){
    for(int k = 1 ; k <= 100 ; k++) //check n
        for(int i = 1 ; i <= 100 ; i++) //check n
            for(int j = 1 ; j <=100 ; j++) //check n
                dist[i][j] = min(dist[i][j] , dist[i][k]+dist[k][j]);
}

///////////////////////////////////////////////////////////////////////////////////////////////////

(( Dijkstra )) : be carefull about the node(tuple) ll or int and the array D
****************

    ll D[100005] , n ;
    vector <pair<ll , ll>> a[100005];
    ll path[100005];
    void dijkstra(int src){
        priority_queue<node, vector<node>, greater<node>> q;
        fill(D, D+n+1, oo);
        D[src]=0; q.push({0, src});
        while(!q.empty()) {
            auto [d, u] = q.top(); q.pop();
            if(d > D[u]) continue;
            for(auto [v, w] : a[u]) {
                if(D[v] > D[u]+w) {
                    D[v] = D[u]+w;
                    path[v] = u;
                    q.push({D[v], v});
                }
            }
        }
    }

///////////////////////////////////////////////////////////////////////////////////////////////////

1 - ((Labyrinth)) : short path between to point with path : 
*******************
//       R   L   D    U
int X[]={0 , 0 , 1 , -1};
int Y[]={1 , -1 , 0 , 0};
char a[1001][1001];
int vis[1001][1001] , n , m , counter = 0;
pair<int,int> st , ed , path[1001][1001];
bool flag = false;
string s = "";
void bfs(int sta , int edd) {
    for(int i=0;i<1001;i++)
        for(int j=0;j<1001;j++)
            vis[i][j] = inf , path[i][j] = {-1,-1};
    queue<pair<int,int>> q;
    q.push({sta,edd}); 
    vis[sta][edd]=0;
    while(!q.empty()) {
        int i = q.front().first , j = q.front().second;
        q.pop();
        for(int k=0;k<4;k++){
            int x = i + X[k];
            int y = j + Y[k];
            if(vis[x][y] == inf  &&  a[x][y] != '#'  &&  x >= 0  &&  x < n   &&  y >= 0  &&  y < m){
                vis[x][y] = vis[i][j] + 1;
                path[x][y] = {i,j};
                q.push({x,y});
            }
        }
    }
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    int t = 1;
    // cin>>t;
    while(t--){
        cin>>n>>m;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                cin>>a[i][j];
                if(a[i][j] == 'A')      st.first = i , st.second = j;
                else if(a[i][j] == 'B')     ed.first = i , ed.second = j;
            }
        }
        bfs(st.first,st.second);
        if(vis[ed.first][ed.second] == inf)     cout<<"NO"<<endl;
        else{
            cout<<"YES"<<endl<<vis[ed.first][ed.second]<<Endl;
            pair <int,int> b = ed , temp;
            while(true){
                temp = path[b.first][b.second];
                if(temp.first == -1  && temp.second == -1)    break;
                if(b.first > temp.first)    s.push_back('D');
                else if(b.first < temp.first)   s.push_back('U');
                else if(b.second > temp.second) s.push_back('R');
                else                            s.push_back('L');
                b = temp;
            }
            for(int i=s.size()-1;i>=0;i--)  cout<<s[i];
            cout<<endl;
        }        
    }
    return 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////

2 -((Round Trip)) : find a cycle in graph of length more than 2 with path
*******************
vector <int> a[100001];
int n , m , root = -1 , leaf = -1;
int vis[nax] , path[nax];
bool flag = false;
vector <int> ans;
void dfs(int i , int father){
    vis[i] = 1;
    for(auto v:a[i]){
        if(!vis[v]){
            path[v] = i;
            dfs(v,i);
        }
        else if(v == father) continue;
        else if(!flag){
            flag = true , root = v , leaf = i;
        }
    }
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    int t = 1;
    // cin>>t;
    while(t--){
        cin>>n>>m;
        for(int i=0;i<m;i++){
            int x , y ; 
            cin>>x>>y;
            a[x].push_back(y);
            a[y].push_back(x);
        }   
        for(int i=1;i<=n;i++){
            if(!vis[i]) dfs(i,0);
            if(flag)    break;
        }
        if(!flag)   cout<<"IMPOSSIBLE"<<endl;
        else{
            ans.push_back(root);
            int i = leaf;
            while(i != root){
                ans.push_back(i);
                i = path[i];
            }
            ans.push_back(i);
            cout<<ans.size()<<endl;
            for(int i=ans.size()-1;i>=0;i--)    cout<<ans[i]<<" ";
            cout<<endl;
        }
    }
    return 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////

3 - ((High Score)) : Single Sorce Longest Path Algorithm (SSLP) (Bellman Ford's Algorithm)
********************
struct triplet{
	int first;
	int second;
	int third;
};
 
int n, m;	
vector<triplet> edges;
vector<int> dist;
 
void bellman_ford()
{
	for(int i = 1; i < n; ++i)
	{
		for(auto e: edges)
		{
			int u = e.first;
			int v = e.second;
			int d = e.third;
			if(dist[u] == oo) continue;
			dist[v] = min(dist[v], d+dist[u]);
			dist[v] = max(dist[v], (ll)-oo);
		}
	} // n relaxations
 
	for(int i = 1; i < n; ++i)
	{
		for(auto e: edges)
		{
			int u = e.first;
			int v = e.second;
			int d = e.third;
			if(dist[u] == oo) continue;
			dist[v] = max(dist[v], (ll)-oo);
			if(dist[u]+d < dist[v])
			{
				dist[v] = -oo;
			}
		}
	}
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    int t = 1;
    // cin>>t;
    while(t--){
        cin >> n >> m;
        dist.resize(n+1);
        edges.resize(m);
        for(int i = 0; i < m; ++i)
        {
            struct triplet inp;
            cin >> inp.first >> inp.second >> inp.third;
            inp.third *= -1; 
            edges[i] = inp;
        }
    
        for(int i = 2; i <= n; ++i)
        {
            dist[i] = oo;
        }
    
        bellman_ford();
        if(dist[n] == -oo)
        {
            cout << -1 << endl;
            return 0;
        } 
        cout << dist[n] * (-1) << endl;
    }
    return 0;
}
==========================================================================================================================================================================

                                                                        Tree
                                                                     ----------
(( DFS )) :
***********
   void dfs(int u, int parent) {
      for(auto v:adj[u]) {
         if(v != parent) {
            dfs(v, u);
         }
      }
   }

///////////////////////////////////////////////////////////////////////////////////////////////////

(( Find the Depth of each node )) : 
***********************************
   int depth[N];
   void dfs(int u, int parent, int d) {
      depth[u] = d;
      for(auto v:adj[u]) {
         if(v != parent) {
            dfs(v, u, d+1);
         }
      }
   }

///////////////////////////////////////////////////////////////////////////////////////////////////

(( Find the size of each sub-tree )) :
**************************************
   int subTreeSize[N];
   int dfs(int u, int parent) {
      subTreeSize[u] = 1; // initially, there's only u
      for(auto v:adj[u]) {
         if(v != parent) {
            int s = dfs(v, u);
            subTreeSize[u] += s;
         }
      }
      return subTreeSize[u];
   }

///////////////////////////////////////////////////////////////////////////////////////////////////

(( Finding the diameter of the tree )) :
****************************************
   int diameter = 0;
   int dfs(int u, int parent) {
      int mx1 = 0;
      int mx2 = 0;
      for(auto v:adj[u]) {
         if(v != parent) { // if it's not the edge we come from
            int h = dfs(v, u) + 1;
            // maintain the two maximum heights
            if(h > mx2) mx2 = h;
            if(mx2 > mx1) swap(mx1, mx2);
         }
      }
      diameter = max(diameter, mx1+mx2);
      return mx1; // return the max height
   }

==========================================================================================================================================================================

                                                                        DP
                                                                     --------
1- ( Max sum in Grid ) : 
************************
int n , m ;
int memo[1000][1000] , a[1000][1000];
int DP(int i , int j){
    if(i == n-1  &&  j == m-1)  return a[i][j];
    if(i >= n  ||  j >= m)  return 0;
    if(memo[i][j] != -1)    return memo[i][j];
    int sum1 = DP(i+1,j);
    int sum2 = DP(i,j+1);
    return memo[i][j] = max(sum1,sum2) + a[i][j];
}

///////////////////////////////////////////////////////////////////////////////////////////////////

2- (RGB Houses) : 
*****************
int n ;
vector <int> r , b , g;
int memo[nax][4];
int dp(int i , int color){
    if(i == n)  return 0;
    if(memo[i][color] != -1)  return memo[i][color];
    int sum1 = inf , sum2 = inf , sum3 = inf;
    if(color == 0){
        sum2 = dp(i+1,1) + b[i];
        sum3 = dp(i+1,2) + g[i];
    }
    else if(color == 1){
        sum1 = dp(i+1,0) + r[i];
        sum3 = dp(i+1,2) + g[i];
    }
    else if(color == 2){
        sum1 = dp(i+1,0) + r[i];
        sum2 = dp(i+1,1) + b[i];
    }
    else {
        sum1 = dp(i+1,0) + r[i];
        sum2 = dp(i+1,1) + b[i];
        sum3 = dp(i+1,2) + g[i];
    }
    return memo[i][color] = min({sum1 , sum2 , sum3});
}


||||||||||||||||||||||||||||||||||||||||||||||| OR |||||||||||||||||||||||||||||||||||||||||||||||||

if(i == n)  return 0;
if(memo[i][color] != -1)  return memo[i][color];
int sum1=inf;
if(color != 0)  sum1 = min (sum1 , r[i] + dp(i+1,0));
if(color != 1)  sum1 = min (sum1 , b[i] + dp(i+1,1));
if(color != 2)  sum1 = min (sum1 , g[i] + dp(i+1,2));    
return memo[i][color] = sum1;

///////////////////////////////////////////////////////////////////////////////////////////////////

3- (Maximal Product) : 
**********************

ll n , m , k;
ll memo[25][102];
ll dp(ll x , ll rem){
    if(x == k){
        if(rem == 0)
            return 1;
        return 0;
    }
    if(rem == 0)    return 0;
    if(memo[x][rem] != -1)   return memo[x][rem];

    ll ans = 0;
    for(int i=1;i<=rem;i++){
        ll sum = i * dp(x+1,rem - i);
        ans = max(ans , sum);
    }
    return memo[x][rem] = ans ;
}

//////////////////////////////////////////////////////////////////////////////////////////////////

4- (longest increasing subsequence) :
*************************************

int n ;
//  if the vale of a[i] small we work by value
// int memo[n][max_number_could_be]

// if the number of elements is small (n is small) we work by index
//  int memo[n+10][n+10];

int memo[100][100];
vector <int> a;
// prev could be index of last number that you did take |OR| could be the number that you did take .
int dp (int i , int  prev){
    if(i == n)  return 0;
    if(memo[i][prev] != -1) return memo[i][prev];
    int sum1 = 0 , sum2 = 0;
    if(a[i] >= prev)     sum1 = dp(i+1,a[i]) + 1;  //  Take if
    sum2 = dp(i+1,prev);                          //  Leave
    return memo[i][prev] = max(sum1,sum2);
}

LIS with binary search :        O(n*log(n))
------------------------
int n , dp[200001] , bs[200001] , a[200001] , ans = 0;
cin>>n;
for(int i=0;i<n;i++)	cin>>a[i];
memset(dp,-1);
bs[0] = 0;
int last = 0;
for(int i=1;i<n;i++){
    if(a[bs[0]] > a[i])		bs[0] = i;
    else if(a[bs[last]] < a[i]){
        ans++;
        last++;
        bs[last] = i;
        dp[i] = bs[last-1];
    }
    else{
        int st = 0 , end = last , mid , indx = 0;
        while(st <= end){
            mid = (st+end) / 2;
            if(a[bs[mid]] < a[i]  &&  a[i] <= a[bs[mid+1]]  &&  mid < last){
                indx = mid + 1;
                break;
            }
            else if(a[bs[mid]] < a[i])	st = mid + 1;
            else						end = mid -1;
        }
        bs[indx] = i;
        dp[i] = bs[indx-1];
    }
}
cout<<ans+1<<endl;
//////////////////////////////////////////////////////////////////////////////////////////////////

5- (0/1 Knapsack) : 
*******************

int n , Max ;
vector <int> w , b;
int memo[1000][1000];
int dp(int i , int rem){
    //  to type : 1- if he ask you to make the rem == 0 , you must check if the rem == 0 or return -inf
    //            2- he didn't say to make rem == 0 so leave it 
    if(i == n)  return 0;
    if(memo[i][rem] != -1)  return memo[i][rem];
    int sum1 = 0 , sum2 = 0;
    if(w[i] <=  rem)    sum1 = dp(i+1,rem - w[i]) + b[i];  // take if
    sum2 = dp(i+1,rem);                                    // Leave
    return memo[i][rem] = max(sum1 , sum2);
}

//////////////////////////////////////////////////////////////////////////////////////////////////

6- (longest common subsets (take from any where (not order)) : 
**************************************************************

string a, b ;
int memo[1000][1000];
// it supose to has the lenght of a , b
int dp(int i , int j){
    if(i == a.size()  ||  j == b.size())  return 0;
    if(memo[i][j] != -1)    return memo[i][j];
    if(a[i] == b[j])    return 1 + dp(i+1,j+1);
    int sum1 = dp(i+1 , j);
    int sum2 = dp(i , j+1);
    return memo[i][j] = max(sum1 , sum2);
}

//////////////////////////////////////////////////////////////////////////////////////////////////

7- (number of coins) : 
**********************

int n = 11 , x;
int a [11] = {5 , 10 , 20 , 50 , 100 , 200 , 500 , 1000 , 2000 , 5000 , 10000};
int memo[nax];
// the length of memo should be the bigest could he give you
int dp(int rem){
    if(rem == 0) return 1;
    if(memo[rem] != -1) return memo[rem];
    int sum = 0;
    for(int i=0;i<n;i++) {
        if(rem >= a[i]) {
            sum = (sum + dp(rem-a[i])) % MOD;
        }
    }
    return memo[rem] = sum;
}

|||||||||||||||||||||||||||||||||||||||||||||| OR ||||||||||||||||||||||||||||||||||||||||||||||||

int n = 11 , x;
int a [11] = {5 , 10 , 20 , 50 , 100 , 200 , 500 , 1000 , 2000 , 5000 , 10000};
int memo[12][30001];
// the length should be the number of coins ans the bigest could he give you
int dp(int i , int rem){
	if(rem == 0)	return 1;

    if(rem < a[i]  ||  i == n)  return 0;

    int &sum = memo[i][rem];
    if(sum  != -1)  return sum;
                // leave it       Take it
    return sum = dp(i+1,rem) + dp(i,rem - a[i]);
}

//////////////////////////////////////////////////////////////////////////////////////////////////

8- (Pearl problem <in 5-th video> ) : 
*************************************

int n , counter[nax] , val[nax];
int memo[1000][1000]; // the size of memo should be (n , the quantinty of each type) 
int dp(int i , int last){
    if(i == n)  return 0;
    int &ret = memo[i][last];
    if(ret != -1)   return ret;
    int sum = 10; //because the problem
    for(int j=last;j<i;j++) 
        sum+=counter[j];          // You can do that by suffix / preffix
    
    ret = dp(i+1,last+1) + sum*val[i]; // Enough Interval

    //add me to hte next interval
    if(i != n-1)
        ret = min(ret , dp(i+1,last));
    
    return ret;
}

|||||||||||||||||||||||||||||||||||||||||||||| OR ||||||||||||||||||||||||||||||||||||||||||||||||

int n , counter[nax] , val[nax];
int memo[1000]; //size of memo is n
int dp(int i){
    if(i == n)  return 0;
    if(memo[i] != -1)   return memo[i];
    int ret = inf  , sum = 0;
    for(int j=i;j<n;j++){
        sum+=counter[j];
        ret = min(ret , (sum+10)*val[j] + dp(j+1));
    }
    return memo[i] = ret;
}

///////////////////////////////////////////////////////////////////////////////////////////////////

9- (Nested Ranges) : 
********************

int n;
int memo[1000][1000]; // (n,n)
int a[nax];
int dp(int i , int j){
    if(j-i+1  <= 2)     //last to numbers (the number on both site)
        return 0;
    if(j-i+1 == 3)  //the last three numbers still
        return a[i]*a[j];
    if(memo[i][j] != -1)
        return memo[i][j];
    int ret = 0;
    for(int k=i+1;k<j;k++){
        ret = max (ret , dp(i,k) + dp(k,j) + a[i]*a[j]);
    }
    return memo[i][j] = ret;
}

//////////////////////////////////////////////////////////////////////////////////////////////////

10- (make string Pilindrom) :
*****************************

int n , memo[1000][1000];  // max length of a 
string  a;
int dp(int i , int j){
    if(i >= j)  return 0;
    if(memo[i][j] != -1)    return memo[i][j];
    int sum1 = 0 , sum2 = 0 , sum3 = 0 ;
    if(a[i] != a[j])
        sum1 = dp(i+1,j-1) + 1;
    else 
        sum1 = dp(i+1,j-1);
    sum2 = dp(i+1,j) + 1;
    sum3 = dp(i,j-1) + 1;
    return memo[i][j] = min({sum1,sum2,sum3});
}

//////////////////////////////////////////////////////////////////////////////////////////////////
11- (counter the numbers of ways that make array plindrom) : 
************************************************************

int n , memo[1000][1000] , a[nax];  // max length of n
int dp(int i , int  j){
    if(i == j)  return 1;
    if(i+1 == j)    return 2 + (a[i] == a[j]);
    int  &ret = memo[i][j];
    if(ret != -1)   return ret;
    
    if(a[i] == a[j])
        ret += dp(i+1,j-1) + 1;
    ret+=dp(i,j-1);
    ret+=dp(i+1,j);
    ret-=dp(i+1,j+1);

    return ret;

//////////////////////////////////////////////////////////////////////////////////////////////////

12- (transform a string to b):
******************************

int n , m , memo[1000][1000];  // max length of a 
string a, b;
int dp(int i , int  j){
    if(i == n)  return m - j;  // if the first string end you must add the remaining of the second to hte answer
    if(j == m)  return n - i;  // if the second string end you must add the remaining of the first to hte answer
    int &ret = memo[i][j];
    if(ret != -1)
        return ret;
    int sum1 = 0 , sum2 = 0 , sum3 = 0;
    if(a[i] == b[j])
        return ret = dp(i+1,j+1);
    sum1 = dp(i+1,j) + 1; // add
    sum2 = dp(i,j+1) + 1;  // remove
    sum3 = dp(i+1,j+1) + 1;  //replace
    return ret = min({sum1,sum2,sum3});
}

//////////////////////////////////////////////////////////////////////////////////////////////////

13- (BitMask):
**************

int setBit(int num , int idx , int value = 1) {return (value) ? (num | (1<<idx) ) : (num &~(1<<idx)) ;}
int getBit(int num , int idx ) {return ((num >> idx) & 1) == 1 ;}
int cntBit(int num){int cntBit(int num){return __builtin_popcount(num);}}

int memo[1<<12];
int dp(int mask){
    int &ret = memo[mask];
    if(ret != -1)   return ret;

    int sum = 0;
    for(int i=0;i<10;i++){
        if(getBit(mask,i)  &&  getBit(mask,i+1)  &&  !getBit(mask,i+2)){
            int sum1 = mask;
            sum1 = setBit(sum1,i,0);
            sum1 = setBit(sum1,i+1,0);
            sum1 = setBit(sum1,i+2,1);
            sum = max(sum,1 + dp(sum1));
        }
        if(!getBit(mask,i)  &&  getBit(mask,i+1)  &&  getBit(mask,i+2)){
            int sum1 = mask;
            sum1 = setBit(sum1,i,1);
            sum1 = setBit(sum1,i+1,0);
            sum1 = setBit(sum1,i+2,0);
            sum = max(sum,1 + dp(sum1));
        }
    }
    return ret = sum;
}


//////////////////////////////////////////////////////////////////////////////////////////////////

14 - (Digit Dp) : 
*****************

#include <iostream>
#include <bits/stdc++.h>
#define ll long long
#define node tuple<int,int>
#define pi 3.14159265359
#define inf 1e9
#define oo 1e18+8
#define log(x , y) log10(y)/log10(x)
#define memset(t , x)  memset(t , x , sizeof t)
#define fill(t , x) fill(t , t+(sizeof t/4) , x)
#define nax (int)(1e6+6)
#define MOD (int)(1e9+7)
#define left 2*i
#define right 2*i+1
#define A(a,n) int a[n];    for(int i=0;i<n;i++)    cin>>a[i];
#define AA(a,n) ll a[n];    for(int i=0;i<n;i++)    cin>>a[i];
#define S(s) string s  ; cin>>s;
#define comma(ans,n)    setprecision(n)<<fixed<<ans<<endl;
#define coutt(x)     printf("%d\n", x);
#define Endl    endl
#define sortt(a)    sort(a.begin(),a.end())
using namespace std;
//#include "debug.cpp"
// Bitmask
int setBit(int num , int idx , int value = 1) {return (value) ? (num | (1<<idx) ) : (num &~(1<<idx)) ;}
int getBit(int num , int idx ) {return ((num >> idx) & 1) == 1 ;}
int cntBit(int num){return __builtin_popcount(num);}

int aa , bb;
string a , b;
int n ;
ll memo[10][3][3];
ll dp(int i , int less , int g){
    if(i == n)  return 0;
    if(memo[i][less][g] != -1)
        return memo[i][less][g];
    ll ret = 0;
    int l = 0 , r = 9;
    if(less == 0)  l = a[i] - '0';
    if(g == 0)  r = b[i] - '0';
    for(int u=l;u<=r;u++){
        ret+= u + dp(i+1,(u > a[i]-'0' ? 1 : less),(u < b[i] - '0' ? 1 : g));
    }
    return memo[i][less][g] = ret;
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    int t = 1;
    while(t){
        cin>>aa>>bb;
        if(aa == -1  &&  bb  == -1)    return 0;
        a = to_string(aa);
        b = to_string(bb);
        cout<<a<<" "<<b<<Endl;
        n = b.size();
        memset(memo,-1);
        reverse(a.begin(),a.end());
        while(b.size() > a.size())
            a.push_back('0');
        reverse(a.begin(),a.end());
        cout<<dp(0,0,0)<<Endl;
    }
    return 0;
}

==========================================================================================================================================================================
                                                                        Segment-Tree
                                                                     -------------------
1- ((Segment Tree)) :
*********************                                                                     
#define left p<<1 , l , (l+r)>>1
#define right p<<1|1 , ((l+r)>>1)+1 , r

vector<int> seg(400100) , a(100100) , lazy(400100);

int build(int p , int l , int r){
    if(l==r) return seg[p] = a[l];
    return seg[p] = (build(left) + build(right)); //to change
}

void push(int p){
    if(!lazy[p]) return;
    seg[p<<1] += lazy[p]; seg[p<<1|1] += lazy[p];
    lazy[p<<1] += lazy[p]; lazy[p<<1|1] +=lazy[p];
    lazy[p] = 0;
}

int update(int i , int j , int inc , int p , int l , int r){
    if(j<l || r<i) return seg[p];
    if(i<=l && r<=j) return lazy[p] += inc, seg[p] += inc; //to change
    push(p);
    return seg[p] = (update(i , j , inc , left) + update(i , j , inc , right)); //to change
}

int query (int i , int j , int p , int l , int r){
    if(j<l  ||  r<i) return inf; // to change
    if(i<=l && r<=j) return seg[p];
    push(p);
    return (query(i , j , left) + query(i , j , right)); //to change
}

//to compress the array
void compress(vector<int> &vec) {
    vector<int> val(vec.begin(), vec.end());
    sort(val.begin(), val.end());
    val.erase(unique(val.begin(), val.end()), val.end());
    for(auto &x:vec) x = lower_bound(val.begin(), val.end(), x) - val.begin();
}

//////////////////////////////////////////////////////////////////////////////////////////////////

2- ((Sparse-Table)) : 
*********************

// to build and answer the query:
vector<vector<int>> st(20 , vector<int> (100100));
vector<int> a(100100);
int n;

void build(){
    for(int i = 0 ; i < n ; i++) st[0][i] = a[i]; // to change
    for(int j = 1 ; 1<<j <= n ; j++)
        for(int i = 0 ; i+(1<<j) <= n ; i++)
            st[j][i] = temp (st[j-1][i] , st[j-1][i+(1<<j-1)]); // to change
}

int inline get (int l , int r){
    int k = log2(r-l+1);
    return temp (st[k][l] , st[k][r-(1<<k)+1]);  //to change
}


// to build and answer range sum queries with complexity log2(n) :

vector<vector<int>> st(20 , vector<int> (100100));

void build(){
    for(int i = 0 ; i < n ; i++) st[0][i] = a[i];
    for (int j = 1 ; 1<<j <= n ; j++)
        for(int i = 0 ; i+(1<<j) <= n ; i++)
            st[j][i] = st[j-1][i] + st[j-1][i+(1<<j-1)];
}

ll inline get (int l , int r){
    ll sum = 0;
    for(int j = 20 ; j >= 0 ; j--){
        if((1<<j) <= r-l+1){
            sum += st[j][l];
            l += 1<<j;
        }
    }
    return sum;
}

//////////////////////////////////////////////////////////////////////////////////////////////////

3-((2D preffix)) : 
******************
vector<vector<int>> prefix2d(1100 , vector<int>(1100)) , a(1000 , vector<int> (1000));

void generate_prefix(int n , int m){
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            prefix2d[i][j] = a[i][j] + prefix2d[i-1][j] + 
                            prefix2d[i][j-1] - prefix2d[i-1][j-1];
}

int get_prefix(int x1 , int y1 , int x2 , int y2){
    return (prefix2d[x2][y2] - prefix2d[x2][y1-1] - prefix2d[x1-1][y2] + prefix2d[x1-1][y1-1]);
}

//////////////////////////////////////////////////////////////////////////////////////////////////

4- ((Fenwick-Tree(BIT))) : 
**************************
// to answer point update and range query
//           range update and point query:

struct FenwickTree {
    vector<int> bit;
    int n;

    FenwickTree(int n) {
        this->n = n;
        bit.assign(n, 0);
    }

    FenwickTree(vector<int> a) : FenwickTree(a.size()) {
        for (size_t i = 0; i < a.size(); i++)
            update(i, a[i]);
    }

    int query(int r) {
        int ret = 0;
        for (; r >= 0; r = (r & (r + 1)) - 1)
            ret += bit[r]; // to change
        return ret;
    }

    int query(int l, int r) {
        return query(r) - query(l - 1);
    }

    void update(int idx, int delta) {
        for (; idx < n; idx = idx | (idx + 1))
            bit[idx] += delta; //to change
    }
    
    void update(int l, int r, int val) {
        update(l, val);
        update(r + 1, -val);
    }
};


// to answer point update and 2d array query:

struct FenwickTree2D {
    vector<vector<int>> bit;
    int n , m;

    FenwickTree2D(int n , int m) {
        this->n = n;
        this->m = m;
        bit.assign(n , vector<int>(m , 0));
    }

    FenwickTree2D(vector<vector<int>> a , int n , int m) : FenwickTree2D(n , m) {
        for (size_t i = 0; i < n; i++)
            for (size_t j = 0; j < m; j++)
                update(i , j , a[i][j]);
    }

    int query(int x, int y) {
        int ret = 0;
        for (int i = x; i >= 0; i = (i & (i + 1)) - 1)
            for (int j = y; j >= 0; j = (j & (j + 1)) - 1)
                ret += bit[i][j];
        return ret;
    }

    void update(int x, int y, int delta) {
        for (int i = x; i < n; i = i | (i + 1))
            for (int j = y; j < m; j = j | (j + 1))
                bit[i][j] += delta;
    }
};

==========================================================================================================================================================================

                                                                            Sort    
                                                                        ------------
1 - ((Restaurant Customers)) : 
******************************

int n;
cin>>n;
vector <pair<int,int>> a;
for(int i=0;i<n;i++){
    int x , y;
    cin>>x>>y;
    a.push_back({x,1});
    a.push_back({y,-1});
}
sortt(a);
int counter = 0 , maxi = -inf;
for(int i=0;i<a.size();i++){    
    counter+=a[i].second;
    // cout<<counter<<endl;
    maxi = max(maxi,counter);
}
cout<<maxi<<endl;

//////////////////////////////////////////////////////////////////////////////////////////////////

2 - ((Movie Festival)) :
************************

int n;
cin>>n;
vector <pair<int,int>> a(n);
for(int i=0;i<n;i++)    cin>>a[i].second>>a[i].first;
sortt(a);
int counter = 0 , last = -1;
for(int i=0;i<n;i++){
    if(a[i].second >= last){
        last = a[i].first;
        counter++;
    }
}
cout<<counter<<endl;

//////////////////////////////////////////////////////////////////////////////////////////////////

3 - ((Maximum Subarray Sum)) :
******************************
int n;
cin>>n;
vector <ll> a(n);
for(int i=0;i<n;i++)    cin>>a[i];
ll last = -oo , maxi = -oo;
for(int i=0;i<n;i++){
    last = max(last+a[i],a[i]);
    maxi = max(maxi,last);
}
cout<<maxi<<endl;

//////////////////////////////////////////////////////////////////////////////////////////////////

4 - ((Missing Coin Sum)) :
**************************

int n;
cin>>n;
vector <int> a(n);
for(int i=0;i<n;i++)    cin>>a[i];
sortt(a);
ll counter = 1;
for(int i=0;i<n;i++){
    if(counter < a[i])  break;
    counter+=a[i];
}
cout<<counter<<endl;

//////////////////////////////////////////////////////////////////////////////////////////////////

5 - ((Playlist)) : 
******************
int n;
cin>>n;
vector <int> a(n);
map<int,int> mp;
for(int i=0;i<n;i++)    cin>>a[i];
int counter = 0 , i = 0 , j = 0 , maxi = -inf ;
while(i < n  &&  j < n){
    int x = mp[a[j]];
    if(x == 0){
        counter++;
        mp[a[j]] = 1;
        j++;
    }
    else{
        mp[a[i]] = 0;
        counter--;
        i++;
    }
    maxi = max(maxi,counter);
}
cout<<maxi<<endl;

//////////////////////////////////////////////////////////////////////////////////////////////////

6 - ((Traffic Lights)) :
************************
int n , m;
cin>>n>>m;
vector <int> a(m)  , ans;
for(int i=0;i<m;i++)    cin>>a[i];
set <int> st;
st.insert(0);
st.insert(n);
multiset <int> mp;
mp.insert(n);
for(int i=0;i<m;i++){
    auto it = st.upper_bound(a[i]);
    int r = *it , l = *--it;
    st.insert(a[i]);
    it = mp.find(r-l);
    mp.erase(it);
    mp.insert(r-a[i]);
    mp.insert(a[i]-l);
    ans.push_back(*mp.rbegin());
}
for(auto it : ans)  cout<<it<<" ";
cout<<endl;

//////////////////////////////////////////////////////////////////////////////////////////////////

7 - ((Subarray Sums I)) :                                  slide window algorithm
*************************
int n , k;
cin>>n>>k;
vector <int> a(n);
for(int i=0;i<n;i++)    cin>>a[i];
ll counter = 0 , sum = 0  , i = 0 , j = 0;
sum = a[0];
while(i < n  &&  j < n){
    if(sum > k){
        sum-= a[i];
        i++;
    }
    else if(sum == k){
        sum-=a[i];
        i++;
        counter++;
    }
    else{
        j++;
        sum+=a[j];
    }
}
if(sum == k)    counter++;
cout<<counter<<endl;

//////////////////////////////////////////////////////////////////////////////////////////////////

8 - ((Subarray Sums II)) : 
**************************
int n , k;
cin>>n>>k;
vector <ll> a(n) , pre(n);
ll counter = 0 , sum = 0;
for(int i=0;i<n;i++){
    cin>>a[i];
    sum+=a[i];
    pre[i] = sum;
}
map <ll,int> mp;
mp[0]++;
for(int i=0;i<n;i++){
    counter += mp[pre[i] - k];
    mp[pre[i]]++;
}
cout<<counter<<endl;

==========================================================================================================================================================================

                                                                            Math    
                                                                        ------------
1 - ((Common Divisors)) :   get the gcd for all pair in array and get the maximum
*************************
int n;
cin>>n;
for(int i=0;i<n;i++){
    int x;
    cin>>x;
    a[x]++;
}
for(int i=1000000;i>0;i--){
    int counter = 0;
    for(int j=i;j<=1000000;j+=i)    counter+=a[j];
    if(counter > 1){
        cout<<i<<endl;
        return 0;
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////

