// freopen("name", "r", stdin)

#define node tuple<int,int>
#define pi 3.14159265359
#define log(x , y) log10(y)/log10(x)
#define left p<<1 , l , (l+r)>>1
#define right p<<1|1 , ((l+r)>>1)+1 , r
#define coutt(x)     printf("%d\n", x);
#define binary(x,n)     std::string str = std::bitset<n>(x).to_string()
#define comma(ans,n)    setprecision(n)<<fixed<<ans<<endl;
#define point complex <int>

printf("%d %d\n%d %d\n", j, i, n - j + 1, m - i + 1);
///////////////////////////////////////////////////////////////////////////////////////////////////
                                                                        Math
                                                                     ----------
(( GCD & LCM )):
****************
   1- if  a=0  ==>  GCD(a.b) = 0

   2- Euclid's : if we want the gcd of (a , b) and we can write a/b = c , a%b = d then GCD(a,b) = GCD(b,d)  and the O(max(a,b))
      code : int GCD(int a , int b){
            if(b == 0)  return a;
            else  return GCD(b,a%b);
      }
   
   3- gcd function with O(min(a,b));
   code : int gcd(int a , int b){
         int mini = min(a,b) , ans;
         for(int i=mini;i>0;i--){
            if(a%i == 0  &&  b%i == 0){
               ans = i ;
               return ans;
            }
         }
   }
    ll lcm(ll a, ll b){
        return (a * b) / __gcd(a,b); 
    }   
   4- GCD(m.a,m.b) = m * GCD(a,b)
   5- GCD(a/m,b/m) = GCD(a,b)/m
   6- GCD(a,b) * LCM(a,b) = a * b
   7- GCD(0,0) = 0 = LCM(0,0)
   8- GCD(a,b,c) = GCD(a,GCD(b,c))
   9- if GCD(a,m) = 1   ==> GCD(m,a*b) = GCD(m,b)
   10- GCD(a,b) = d  ==> GCD(a/d,b/d) = 1
   11- GCD(a,b) = GCD(b,a%b)
   12- GCD(a,a+1) = 1
   13- Find three distinct positive integers a, b, c such that a+b+c=n and gcd(a,b)=c, where gcd(x,y)
      ll n ;
        cin>>n;
        if(n%2 == 0){
            cout<<n-3<<" "<<2<<" "<<1<<Endl;
        }
        else{
            for(ll i=2;i<n/2;i++){
                if(__gcd(n-i-1,i) == 1){
                    cout<<n-i-1<<" "<<i<<" "<<1<<endl;
                    break;
                }
            }
        }
///////////////////////////////////////////////////////////////////////////////////////////////////

(( Prime )):
************
1- sieve : 
    int isPrime[1000001];
    void sieve(){
        for(int i=1; i<=1000000; i++){
            isPrime[i]=1;
        }
        isPrime[1]=0;
        for(int i=1; i<=1000; i++){
            if(isPrime[i]==1){
                for(int j=i*i; j<=1000000; j+=i)
                    isPrime[j]=0;
            }
        }
    }
2- Nive Approach : O(n)
   void checkPrime(int n){
      int count = 0 ;
      for(int i=1;i<=n;i++)
         if(n%i == 0)   
            count++;
      if(count == 2)
         cout<<"N is prime"<<endl;
      else
         cout<<"N is no't Prime"<<endl;
   }

3- Nive Approach : O(sqrt(n))
   void checkPrime(int n){
      int count = 0 ;
      for(int i=1;i*i<=n;i++){
         if(n%i == 0){
            if(i*i == n)   count++;
            else           count+=2;
         }
      }
      if(count == 2)
         cout<<"N is prime"<<endl;
      else
         cout<<"N is no't Prime"<<endl;
   }

///////////////////////////////////////////////////////////////////////////////////////////////////

(( modulo )) : 
**************
         *               *
   1- (a + b)%c  =  (a%c + b%c)%c
   2- ll MOD = 1e9 + 7;
      ll bigMod(ll x,ll y){
         if (y == 0)return 1;
         if (y == 1)return x;
         ll res = bigMod(x , y / 2LL);
         res *= res;
         res %= MOD;
         if (y % 2){
            res *= x;
            res %= MOD;
         }
         return res;
      }
    3 - n mod x = y mod n
        if(x > y)   n = (x + y)

///////////////////////////////////////////////////////////////////////////////////////////////////
((Fast Power)) : 
****************
ll fastpow(ll a,ll n){
    if(!n)
        return 1;
    ll mul = fastpow(a,n/2);
    mul = (mul*mul)%MOD;
    if(n&1)
        mul = (a*mul)%MOD;
    return mul;
}
///////////////////////////////////////////////////////////////////////////////////////////////////

(( Factorial )) :
*****************
   1- Factorial : O(n)
      int factorial(int n){
         return (n == 1 || n == 0) ? 1 : n * factorial(n - 1);
      }

   2- Prime Factorial :
      void primeFactorial(int n){
         while(n%2 == 0){
            n/2;
         }
         for(int i=3;i<sqrt(n);i+=2){
            while(n%i == 0){
               cout<<i<<" ";
               n/=i;
            }
         }
         if(n > 2)   cout<<n;
      }

    int factorization(int x) // O( sqrt (x) )
    {
        vector<int> v;
        for (int i = 2; i * i <= x; i++)
        {
            while (x % i == 0)
            {
                x /= i;
                v.push_back(i);
            }
        }
        if (x > 1)
            v.push_back(x);
        return v.size();
    }
///////////////////////////////////////////////////////////////////////////////////////////////////

((Divisors of number)):
***********************

set <int> divisors;

void getDivisors(int n){
    for (int i = 1 ; i*i <= n ; i++){
        if(n%i==0){
            int x = n/i;
            divisors.insert(i);
            if(x!=i) divisors.insert(x);
        }
    }
}


((Divisors using sieve for 1->n number)):
******************************************
vector<vector<int>> allDivisors;

void getDivisorsToN(int n){
    for(int i=1 ; i<n ; i++)
        for(int j=i ; j<n ; j+=i)
            allDivisors[j].push_back(i);
}

///////////////////////////////////////////////////////////////////////////////////////////////////

((Combinatorics)):
*****************

const int N = 2020   //  To Change ;
const int Mod = 1e9 + 7  //  To Change;
 
int Inv[N];
int Fact[N];
int iFact[N];
 
void add_self(int& x, int y)
{
    if((x += y) >= Mod) x -= Mod;
}
 
int add(int x, int y)
{
    return add_self(x, y), x;
}
 
void sub_self(int& x, int y)
{
    if((x -= y) < 0)    x += Mod;
}
 
int sub(int x, int y)
{
    return sub_self(x, y), x;
}
 
int mul(int x, int y)
{
    return (long long) x * y % Mod;
}
 
int C(int n, int r)
{
    if(n < 0 || r < 0 || n < r) return 0;
    return mul(Fact[n], mul(iFact[r], iFact[n - r]));
}
 
int fp(int x, int y)
{
    int Res = 1;
    for( ; y > 0; y >>= 1, x = mul(x, x))
        if(y & 1)
            Res = mul(Res, x);
    return Res;
}
 
void PreCalcMod()
{
    Inv[1] = 1;
    for(int i = 2; i < N; i++)  Inv[i] = sub(0, mul(Mod / i, Inv[Mod % i]));
 
    Fact[0] = iFact[0] = 1;
    for(int i = 1; i < N; i++)  Fact[i] = mul(i, Fact[i - 1]);
    for(int i = 1; i < N; i++)  iFact[i] = mul(Inv[i], iFact[i - 1]);
}
 
 
==========================================================================================================================================================================

                                                                           Graph
                                                                        -----------
//       R   L   D    U
int X[]={0 , 0 , 1 , -1};
int Y[]={1 , -1 , 0 , 0};
for(int k=0;k<4;k++){
    int x = i + X[k];
    int y = j + Y[k];
    if(x > 0  &&  x <= n  &&  y > 0  &&  y <= m  &&  !vis[x][y])    dfs(x,y);
}
(( DFS )) : 
***********
    int vis[nax];
    void dfs(int i) {
        vis[i] = 1;
        for(auto v:a[i]) {
            if(!vis[v]) {
                dfs(v);
            }
        }
    }

///////////////////////////////////////////////////////////////////////////////////////////////////

(( BFS )) :
***********
    int D[nax];
    void bfs(int src) {
        for(int i=0 ; i<=n ; i++) D[i] = inf;
        queue<int> q;
        q.push(src); D[src]=0;
        while(!q.empty()){
            int u = q.front();
            q.pop();
            for(auto v:a[u]){
                if(D[v] == inf){
                    D[v] = D[u] + 1;
                    q.push(v);
                }
            }
        }
    }



///////////////////////////////////////////////////////////////////////////////////////////////////

(( Multi Source BFS )) :
************************
int D[nax];
set <int> source;

void multiSorceBfs() {
    for(int i=0 ; i<=n ; i++) D[i] = inf;
    queue <int> q;
    for(auto it : source){
        q.push(it);
        D[it] = 0;
    }
    while(!q.empty()){
        int u = q.front();
        q.pop();
        for(auto v:a[u]){
            if(D[v] == inf){
                D[v] = D[u] + 1;
                q.push(v);
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////////

(( DSU )) :
***********

struct DSU{
    vector<int> par, siz;
    int comp;

    DSU(int n) {
        par.assign(n, 0);
        siz.assign(n, 1);
        iota(par.begin(), par.end(), 0);
        comp=n;
    }

    int find(int x) {
        while(x!=par[x]) par[x]=par[par[x]], x=par[x];
        return x;
    }
    // merge v to u
    // v parent for the first time
    void merge(int u, int v) {
        int a=find(u);
        int b=find(v);
        if(a==b) return;
        comp--;
        if(siz[a]>siz[b]) swap(a, b);
        siz[b]+=siz[a];
        siz[a]=0;
        par[a]=par[b];
    }     
};

///////////////////////////////////////////////////////////////////////////////////////////////////

(( Floyd )) :
*************
vector<vector<int>> dist(1000 , vector<int> (1000));

void floyd(){
    for(int k = 1 ; k <= 100 ; k++) //check n
        for(int i = 1 ; i <= 100 ; i++) //check n
            for(int j = 1 ; j <=100 ; j++) //check n
                dist[i][j] = min(dist[i][j] , dist[i][k]+dist[k][j]);
}

///////////////////////////////////////////////////////////////////////////////////////////////////

(( Dijkstra )) : be carefull about the node(tuple) ll or int and the array D
****************

#define node tuple<int,int>


    ll D[100005] , n ;
    vector <pair<ll , ll>> a[100005];
    ll path[100005];
    void dijkstra(int src){
        priority_queue<node, vector<node>, greater<node>> q;
        fill(D, D+n+1, oo);
        D[src]=0; q.push({0, src});
        while(!q.empty()) {
            auto [d, u] = q.top(); q.pop();
            if(d > D[u]) continue;
            for(auto [v, w] : a[u]) {
                if(D[v] > D[u]+w) {
                    D[v] = D[u]+w;
                    path[v] = u;
                    q.push({D[v], v});
                }
            }
        }
    }

///////////////////////////////////////////////////////////////////////////////////////////////////

(( Find cycle )) : 
******************
    // Undirected
    int n;
    int vis[nax] , parent[nax];
    int cycle_start , cycle_end;

    bool dfs(int v, int par) { // passing vertex and its parent vertex
        vis[v] = true;
        for (int u : a[v]) {
            if(u == par) continue; // skipping edge to parent vertex
            if (vis[u]) {
                cycle_end = v;
                cycle_start = u;
                return true;
            }
            parent[u] = v;
            if (dfs(u, parent[u]))
                return true;
        }
        return false;
    }

    // Directed
    bool dfs(int v) { // passing vertex and its parent vertex
        vis[v] = 1;
        vis2[v] = 1;
        for (int u : a[v]) {
            if(vis2[u])    return true;
            parent[u] = v;
            if(!vis[u]  &&  dfs(u)){
                return true;
            }
        }
        vis2[v] = 0;
        return false;
    }


///////////////////////////////////////////////////////////////////////////////////////////////////

(( Bipartite Graph )) : 
***********************

    bool is_bipartite = true;
    vector <int> color(nax,-1);

    void bfs(int src) {
        queue<int> q;
        q.push(src);
        color[src] = 0;
        while(!q.empty()){
            int u = q.front();
            q.pop();
            for(auto v:a[u]){
                if(color[v] == -1){
                    color[v] = color[u] ^ 1;
                    q.push(v);
                }else{
                    is_bipartite &= color[v] != color[u];
                }
            }
        }
    }

///////////////////////////////////////////////////////////////////////////////////////////////////

1 - ((Labyrinth)) : short path between to point with path : 
*******************
//       R   L   D    U
int X[]={0 , 0 , 1 , -1};
int Y[]={1 , -1 , 0 , 0};
char a[1001][1001];
int vis[1001][1001] , n , m , counter = 0;
pair<int,int> st , ed , path[1001][1001];
bool flag = false;
string s = "";
void bfs(int sta , int edd) {
    for(int i=0;i<1001;i++)
        for(int j=0;j<1001;j++)
            vis[i][j] = inf , path[i][j] = {-1,-1};
    queue<pair<int,int>> q;
    q.push({sta,edd}); 
    vis[sta][edd]=0;
    while(!q.empty()) {
        int i = q.front().first , j = q.front().second;
        q.pop();
        for(int k=0;k<4;k++){
            int x = i + X[k];
            int y = j + Y[k];
            if(vis[x][y] == inf  &&  a[x][y] != '#'  &&  x >= 0  &&  x < n   &&  y >= 0  &&  y < m){
                vis[x][y] = vis[i][j] + 1;
                path[x][y] = {i,j};
                q.push({x,y});
            }
        }
    }
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    int t = 1;
    // cin>>t;
    while(t--){
        cin>>n>>m;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                cin>>a[i][j];
                if(a[i][j] == 'A')      st.first = i , st.second = j;
                else if(a[i][j] == 'B')     ed.first = i , ed.second = j;
            }
        }
        bfs(st.first,st.second);
        if(vis[ed.first][ed.second] == inf)     cout<<"NO"<<endl;
        else{
            cout<<"YES"<<endl<<vis[ed.first][ed.second]<<Endl;
            pair <int,int> b = ed , temp;
            while(true){
                temp = path[b.first][b.second];
                if(temp.first == -1  && temp.second == -1)    break;
                if(b.first > temp.first)    s.push_back('D');
                else if(b.first < temp.first)   s.push_back('U');
                else if(b.second > temp.second) s.push_back('R');
                else                            s.push_back('L');
                b = temp;
            }
            for(int i=s.size()-1;i>=0;i--)  cout<<s[i];
            cout<<endl;
        }        
    }
    return 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////

2 -((Round Trip)) : find a cycle in graph of length more than 2 with path
*******************
vector <int> a[100001];
int n , m , root = -1 , leaf = -1;
int vis[nax] , path[nax];
bool flag = false;
vector <int> ans;
void dfs(int i , int father){
    vis[i] = 1;
    for(auto v:a[i]){
        if(!vis[v]){
            path[v] = i;
            dfs(v,i);
        }
        else if(v == father) continue;
        else if(!flag){
            flag = true , root = v , leaf = i;
        }
    }
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    int t = 1;
    // cin>>t;
    while(t--){
        cin>>n>>m;
        for(int i=0;i<m;i++){
            int x , y ; 
            cin>>x>>y;
            a[x].push_back(y);
            a[y].push_back(x);
        }   
        for(int i=1;i<=n;i++){
            if(!vis[i]) dfs(i,0);
            if(flag)    break;
        }
        if(!flag)   cout<<"IMPOSSIBLE"<<endl;
        else{
            ans.push_back(root);
            int i = leaf;
            while(i != root){
                ans.push_back(i);
                i = path[i];
            }
            ans.push_back(i);
            cout<<ans.size()<<endl;
            for(int i=ans.size()-1;i>=0;i--)    cout<<ans[i]<<" ";
            cout<<endl;
        }
    }
    return 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////

3 - ((High Score)) : Single Sorce Longest Path Algorithm (SSLP) (Bellman Ford's Algorithm)
********************
struct triplet{
	int first;
	int second;
	int third;
};
 
int n, m;	
vector<triplet> edges;
vector<int> dist;
 
void bellman_ford()
{
	for(int i = 1; i < n; ++i)
	{
		for(auto e: edges)
		{
			int u = e.first;
			int v = e.second;
			int d = e.third;
			if(dist[u] == oo) continue;
			dist[v] = min(dist[v], d+dist[u]);
			dist[v] = max(dist[v], (ll)-oo);
		}
	} // n relaxations
 
	for(int i = 1; i < n; ++i)
	{
		for(auto e: edges)
		{
			int u = e.first;
			int v = e.second;
			int d = e.third;
			if(dist[u] == oo) continue;
			dist[v] = max(dist[v], (ll)-oo);
			if(dist[u]+d < dist[v])
			{
				dist[v] = -oo;
			}
		}
	}
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    int t = 1;
    // cin>>t;
    while(t--){
        cin >> n >> m;
        dist.resize(n+1);
        edges.resize(m);
        for(int i = 0; i < m; ++i)
        {
            struct triplet inp;
            cin >> inp.first >> inp.second >> inp.third;
            inp.third *= -1; 
            edges[i] = inp;
        }
    
        for(int i = 2; i <= n; ++i)
        {
            dist[i] = oo;
        }
    
        bellman_ford();
        if(dist[n] == -oo)
        {
            cout << -1 << endl;
            return 0;
        } 
        cout << dist[n] * (-1) << endl;
    }
    return 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////

(( finding bridges in a graph )) :
**********************************

int vis[nax] , tin[nax] , low[nax];
int timer = 0;
void dfs(int i , int parent) {
    vis[i] = 1;
    tin[i] = low[i] = timer++;
    for(auto v:a[i]) {
        if(v == parent) continue;
        if(vis[v]){
            //  Back Edge
            low[i] = min(low[i], tin[v]);
        }else{
            //  Forward Edge
            dfs(v);
            low[i] = min(low[i], low[v]);
            if (low[v] > tin[i])
                IS_BRIDGE(i, v);
        }
    }
}

==========================================================================================================================================================================

                                                                        Tree
                                                                     ----------
(( DFS )) :
***********
   void dfs(int u, int parent) {
      for(auto v:adj[u]) {
         if(v != parent) {
            dfs(v, u);
         }
      }
   }

///////////////////////////////////////////////////////////////////////////////////////////////////

(( Find the Depth of each node )) : 
***********************************
   int depth[N];
   void dfs(int u, int parent, int d) {
      depth[u] = d;
      for(auto v:adj[u]) {
         if(v != parent) {
            dfs(v, u, d+1);
         }
      }
   }

///////////////////////////////////////////////////////////////////////////////////////////////////

(( Find the size of each sub-tree )) :
**************************************
   int subTreeSize[N];
   int dfs(int u, int parent) {
      subTreeSize[u] = 1; // initially, there's only u
      for(auto v:adj[u]) {
         if(v != parent) {
            int s = dfs(v, u);
            subTreeSize[u] += s;
         }
      }
      return subTreeSize[u];
   }

///////////////////////////////////////////////////////////////////////////////////////////////////

(( Finding the diameter of the tree )) :
****************************************
   int diameter = 0;
   int dfs(int u, int parent) {
      int mx1 = 0;
      int mx2 = 0;
      for(auto v:adj[u]) {
         if(v != parent) { // if it's not the edge we come from
            int h = dfs(v, u) + 1;
            // maintain the two maximum heights
            if(h > mx2) mx2 = h;
            if(mx2 > mx1) swap(mx1, mx2);
         }
      }
      diameter = max(diameter, mx1+mx2);
      return mx1; // return the max height
   }

///////////////////////////////////////////////////////////////////////////////////////////////////

((Spanning Tree)) :
*******************
struct DSU{
    vector<int> par, siz;
    int comp;

    DSU(int n) {
        par.assign(n, 0);
        siz.assign(n, 1);
        iota(par.begin(), par.end(), 0);
        comp=n;
    }

    int find(int x) {
        while(x!=par[x]) par[x]=par[par[x]], x=par[x];
        return x;
    }
    // merge v to u
    // v parent for the first time
    void merge(int u, int v) {
        int a=find(u);
        int b=find(v);
        if(a==b) return;
        comp--;
        if(siz[a]>siz[b]) swap(a, b);
        siz[b]+=siz[a];
        siz[a]=0;
        par[a]=par[b];
    }     
};

// if maximum change the sort function

struct Edge {
    int u, v, weight;
    bool operator<(Edge const& other) {
        return weight < other.weight;
    }
};

int n , m;
vector <Edge> edges;
int cost = 0;


main :
------

    for(int i=0;i<m;i++){
        int x , y , z;
        cin >> x >> y >> z;
        Edge temp;
        temp.u = x , temp.v = y , temp.weight = z;
        edges.push_back(temp);
    }
    sortt(edges);
    DSU dsu(n+10);
    for(int i=0;i<m;i++){
        auto it = edges[i];
        if(dsu.find(it.u) != dsu.find(it.v))
            cost += it.weight;
            dsu.merge(it.v,it.u);
        }
    }

///////////////////////////////////////////////////////////////////////////////////////////////////

((Mo's on Tree)) :   
******************

1 - This struct solve query not dynamic on tree to answer about subtree

int n , q , block_size , timer = 1;
vector <int> tree[nax];
/**
 * a    : Euler array size 2 * n;
 * L[i] : The left index of node in Euler array 
 * R[i] : The right indx of node in Euler array
*/
vector <int> L(nax) , R(nax) , a(nax);
vector <int> F(nax) , FF(nax);
vector <int> answers(nax);

struct Query {
    int l, r, k, idx;
    bool operator<(Query other) const
    {
        return make_pair(l / block_size, r) <
               make_pair(other.l / block_size, other.r);
    }
};

void remove(int idx){   // TODO: remove value idx from data structure
    
}
void add(int idx){      // TODO: add value idx from data structure
    
}
int get_answer(){       // TODO: Return the answer value
    
} 

//  Euler DFS
void dfs(int node , int par){
    L[node] = timer;
    a[timer] = node;
    timer++;
    for(int child : tree[node])
        if(child != par)
            dfs(child , node);
    R[node] = timer;
    a[timer] = node;
    timer++;
}
 


main : 
    cin >> n >> q;
    for(int i=1;i<n;i++){
        int x , y;
        cin >> x >> y;
        tree[x].push_back(y);
        tree[y].push_back(x);
    }
    timer = 1;

    // Root
    dfs(1,-1);
    
    vector <Query> query;
    block_size = (int) sqrt (n + .0) + 1;
    for(int i=0;i<q;i++){
        int sub , k;
        cin >> sub >> k; 
        Query x;
        x.l = L[sub] , x.r = R[sub] , x.idx = i , x.k = k;
        query.push_back(x);
    }

    sort(query.begin(),query.end());
    int cur_l = 1 , cur_r = 0;
    for(auto q : query) {
        while(cur_l > q.l){
            cur_l--;
            add(a[cur_l]);
        }
        while(cur_r < q.r){
            cur_r++;
            add(a[cur_r]);
        }
        while(cur_l < q.l){
            remove(a[cur_l]);
            cur_l++;
        }
        while(cur_r > q.r){
            remove(a[cur_r]);
            cur_r--;
        }
        answers[q.idx] = get_answer();
    }
    for(int i=0;i<q;i++)    cout << answers[i] << endl;

///////////////////////////////////////////////////////////////////////////////////////////////////

2 - This struct solve query not dynamic on tree to answer about path from u to v

int n , q , block_size , timer = 1;
vector <int> tree[nax];
/**
 * a    : Euler array size 2 * n;
 * L[i] : The left index of node in Euler array 
 * R[i] : The right indx of node in Euler array
*/
vector <int> L(nax) , R(nax) , a(nax);
vector <int> F(nax) , vis(nax) , depth(nax);
vector <int> answers(nax) , color(nax);
int LCA[nax][25];

struct Query {
    int l, r, k, idx , lca;
    bool operator<(Query other) const
    {
        return make_pair(l / block_size, r) <
               make_pair(other.l / block_size, other.r);
    }
};

void remove(int idx){   // TODO: remove value idx from data structure
    
}
void add(int idx){      // TODO: add value idx from data structure
    
}
int get_answer(){       // TODO: Return the answer value
    
} 

//  Euler DFS
void dfs(int node , int par , int d){
    depth[node] = d;
    LCA[node][0] = par;

    L[node] = timer;
    a[timer] = node;
    timer++;
    for(int child : tree[node])
        if(child != par)
            dfs(child , node , d + 1);
    R[node] = timer;
    a[timer] = node;
    timer++;
}

// Binary lefting
void init(int n){
    for(int j=1;j<25;j++){
        for(int i=1;i<=n;i++){
            if(LCA[i][j-1] != -1){
                LCA[i][j] = LCA[LCA[i][j-1]][j-1];
            }
        }
    }
}

int getLCA(int a , int b){
    if(depth[a] > depth[b])     swap(a , b);

    int d = depth[b] - depth[a];
    int f = 0;
    while(d){
        if(d&1)     b = LCA[b][f];

        d >>= 1;
        f++;
    }
    if(a == b){
        return a;
    }
    for(int j=24;j>=0;j--){
        if(LCA[a][j] != -1  &&  (LCA[a][j] != LCA[b][j])){
            a = LCA[a][j];
            b = LCA[b][j];
        }
    }
    return LCA[a][0];
}


main : 
        cin >> n >> q;

        /* intialize
            for(int i=0;i<=n;i++){
                tree[i].clear();
                vis[i] = 0;
                F[i] = 0;
            }
            for(int i=0;i<=q;i++)   answers[i] = 0;
        */

        for(int i=1;i<n;i++){
            int x , y;
            cin >> x >> y;
            tree[x].push_back(y);
            tree[y].push_back(x);
        }
        timer = 1;
        memset(LCA , -1);
        // Root
        dfs(1 , -1 , 0);
        init(n);
        
        vector <Query> query;
        block_size = (int) sqrt (n + .0) + 1;
        for(int i=0;i<q;i++){
            int u , v , k , lca;
            cin >> u >> v >> k;
            Query x;

            if(L[u] > L[v])     swap(u , v);    // always start of u must be smaller than start of v
            lca = getLCA(u , v);

            /**
             * There to type of query
             * 1- V is in the subTree of U  ==> the query from L[u] to L[v]
             * 2- V isn't int the subTree of U  ==> the query from L[u] to L[v] and lca
            */
            if(u == lca)    
                x.l = L[u] , x.r = L[v] , x.idx = i , x.k = k , x.lca = -1;
            else   
                x.l = R[u] , x.r = L[v] , x.idx = i , x.k = k , x.lca = lca;
            query.push_back(x);
        }

        sort(query.begin(),query.end());
        int cur_l = 1 , cur_r = 0;
        for(auto q : query) {
            while(cur_l > q.l){
                cur_l--;
                add(a[cur_l]);
            }
            while(cur_r < q.r){
                cur_r++;
                add(a[cur_r]);
            }
            while(cur_l < q.l){
                remove(a[cur_l]);
                cur_l++;
            }
            while(cur_r > q.r){
                remove(a[cur_r]);
                cur_r--;
            }
            answers[q.idx] = get_answer();
        }
        for(int i=0;i<q;i++)    cout << answers[i] << endl;

///////////////////////////////////////////////////////////////////////////////////////////////////

((Centroid Decomposition)):
**************************

int n;
set <int> a[nax];
vector <int> parent(nax) , sub(nax) , res(nax);
vector <int> newTree[nax];

// Calc the size of each node
int dfs1(int node , int par){
    sub[node] = 1;
    for(auto v : a[node]){
        if(v != par){
            sub[node] += dfs1(v , node);
        }
    }
    return sub[node];   
}
// Return centroid
int dfs2(int node , int par , int n){
    for(auto v : a[node]){
        if(v != par  &&  sub[v] > n / 2){
            return dfs2(v , node , n);
        }
    }
    return node;
}

int decompose(int node , int par){
    int subTreeSize = dfs1(node , -1);
    int centroid = dfs2(node , par , subTreeSize);

    parent[centroid] = par;
    for(auto v : a[centroid]){
        a[v].erase(centroid);
        int x = decompose(v , centroid);
        newTree[centroid].push_back(x);
    }
    return centroid;
}

void update(int node){
    int cur = node;
    while(cur != -1){
        // make the solution of the problem
        cur = parent[cur];
    }
}

int query(int node){
    int cur = node;
    int ans = inf;
    while(cur != -1){
        // make the solution of the problem
        cur = parent[cur];
    }
    return ans;
}

main :
        cin >> n;
        for(int i=1;i<n;i++){
            int x , y;
            cin >> x >> y;
            a[x].insert(y);
            a[y].insert(x);
        }
        decompose(1 , -1);
        for(int i=0;i<=n;i++)   res[i] = inf;


///////////////////////////////////////////////////////////////////////////////////////////////////

((Range Query On Trees)):
**************************
1- find dynamics query (min , max) of Subtree
2- find dynamics query (sum , XOR) of path or subTree

NOTE : if was path change to lca solution

#define left p<<1 , l , (l+r)>>1
#define right p<<1|1 , ((l+r)>>1)+1 , r

int n , q , timer = 0;
vector <int> tree[nax] , sub(nax) , L(nax) , color(nax);
vector <int> seg(400100) , a(100100) , lazy(400100);

//  Euler DFS
int dfs(int node , int par){
    L[node] = timer;
    a[timer++] = color[node];
    
    sub[node] = 1;
    for(int child : tree[node])
        if(child != par)
            sub[node] += dfs(child , node);

    return sub[node];
}
 

int build(int p , int l , int r){
    if(l==r) return seg[p] = a[l];
    return seg[p] = (build(left) + build(right)); //to change
}

void push(int p){
    if(!lazy[p]) return;
    seg[p<<1] += lazy[p]; seg[p<<1|1] += lazy[p];
    lazy[p<<1] += lazy[p]; lazy[p<<1|1] +=lazy[p];
    lazy[p] = 0;
}

int update(int i , int j , int inc , int p , int l , int r){
    if(j<l || r<i) return seg[p];
    if(i<=l && r<=j) return lazy[p] += inc, seg[p] += inc;
    push(p);
    return seg[p] = (update(i , j , inc , left) + update(i , j , inc , right)); //to change
}

int query (int i , int j , int p , int l , int r){
    if(j<l  ||  r<i) return 0; // to change
    if(i<=l && r<=j) return seg[p];
    push(p);
    return (query(i , j , left) + query(i , j , right)); //to change
}

==========================================================================================================================================================================

                                                                        DP
                                                                     --------
1- ( Max sum in Grid ) : 
************************
int n , m ;
int memo[1000][1000] , a[1000][1000];
int DP(int i , int j){
    if(i == n-1  &&  j == m-1)  return a[i][j];
    if(i >= n  ||  j >= m)  return 0;
    if(memo[i][j] != -1)    return memo[i][j];
    int sum1 = DP(i+1,j);
    int sum2 = DP(i,j+1);
    return memo[i][j] = max(sum1,sum2) + a[i][j];
}

///////////////////////////////////////////////////////////////////////////////////////////////////

2- (RGB Houses) : 
*****************
int n ;
vector <int> r , b , g;
int memo[nax][4];
int dp(int i , int color){
    if(i == n)  return 0;
    if(memo[i][color] != -1)  return memo[i][color];
    int sum1 = inf , sum2 = inf , sum3 = inf;
    if(color == 0){
        sum2 = dp(i+1,1) + b[i];
        sum3 = dp(i+1,2) + g[i];
    }
    else if(color == 1){
        sum1 = dp(i+1,0) + r[i];
        sum3 = dp(i+1,2) + g[i];
    }
    else if(color == 2){
        sum1 = dp(i+1,0) + r[i];
        sum2 = dp(i+1,1) + b[i];
    }
    else {
        sum1 = dp(i+1,0) + r[i];
        sum2 = dp(i+1,1) + b[i];
        sum3 = dp(i+1,2) + g[i];
    }
    return memo[i][color] = min({sum1 , sum2 , sum3});
}


||||||||||||||||||||||||||||||||||||||||||||||| OR |||||||||||||||||||||||||||||||||||||||||||||||||

if(i == n)  return 0;
if(memo[i][color] != -1)  return memo[i][color];
int sum1=inf;
if(color != 0)  sum1 = min (sum1 , r[i] + dp(i+1,0));
if(color != 1)  sum1 = min (sum1 , b[i] + dp(i+1,1));
if(color != 2)  sum1 = min (sum1 , g[i] + dp(i+1,2));    
return memo[i][color] = sum1;

///////////////////////////////////////////////////////////////////////////////////////////////////

3- (Maximal Product) : 
**********************

ll n , m , k;
ll memo[25][102];
ll dp(ll x , ll rem){
    if(x == k){
        if(rem == 0)
            return 1;
        return 0;
    }
    if(rem == 0)    return 0;
    if(memo[x][rem] != -1)   return memo[x][rem];

    ll ans = 0;
    for(int i=1;i<=rem;i++){
        ll sum = i * dp(x+1,rem - i);
        ans = max(ans , sum);
    }
    return memo[x][rem] = ans ;
}

//////////////////////////////////////////////////////////////////////////////////////////////////

4- (longest increasing subsequence) :
*************************************

int n ;
//  if the vale of a[i] small we work by value
// int memo[n][max_number_could_be]

// if the number of elements is small (n is small) we work by index
//  int memo[n+10][n+10];

int memo[100][100];
vector <int> a;
// prev could be index of last number that you did take |OR| could be the number that you did take .
int dp (int i , int  prev){
    if(i == n)  return 0;
    if(memo[i][prev] != -1) return memo[i][prev];
    int sum1 = 0 , sum2 = 0;
    if(a[i] >= prev)     sum1 = dp(i+1,a[i]) + 1;  //  Take if
    sum2 = dp(i+1,prev);                          //  Leave
    return memo[i][prev] = max(sum1,sum2);
}

LIS with binary search :        O(n*log(n))
------------------------
int n , dp[200001] , bs[200001] , a[200001] , ans = 0;
cin>>n;
for(int i=0;i<n;i++)	cin>>a[i];
memset(dp,-1);
bs[0] = 0;
int last = 0;
for(int i=1;i<n;i++){
    if(a[bs[0]] > a[i])		bs[0] = i;
    else if(a[bs[last]] < a[i]){
        ans++;
        last++;
        bs[last] = i;
        dp[i] = bs[last-1];
    }
    else{
        int st = 0 , end = last , mid , indx = 0;
        while(st <= end){
            mid = (st+end) / 2;
            if(a[bs[mid]] < a[i]  &&  a[i] <= a[bs[mid+1]]  &&  mid < last){
                indx = mid + 1;
                break;
            }
            else if(a[bs[mid]] < a[i])	st = mid + 1;
            else						end = mid -1;
        }
        bs[indx] = i;
        dp[i] = bs[indx-1];
    }
}
cout<<ans+1<<endl;
//////////////////////////////////////////////////////////////////////////////////////////////////

5- (0/1 Knapsack) : 
*******************

int n , Max ;
vector <int> w , b;
int memo[1000][1000];
int dp(int i , int rem){
    //  to type : 1- if he ask you to make the rem == 0 , you must check if the rem == 0 or return -inf
    //            2- he didn't say to make rem == 0 so leave it 
    if(i == n)  return 0;
    if(memo[i][rem] != -1)  return memo[i][rem];
    int sum1 = 0 , sum2 = 0;
    if(w[i] <=  rem)    sum1 = dp(i+1,rem - w[i]) + b[i];  // take if
    sum2 = dp(i+1,rem);                                    // Leave
    return memo[i][rem] = max(sum1 , sum2);
}

//////////////////////////////////////////////////////////////////////////////////////////////////

6- (longest common subsets (take from any where (not order)) : 
**************************************************************

string a, b ;
int memo[1000][1000];
// it supose to has the lenght of a , b
int dp(int i , int j){
    if(i == a.size()  ||  j == b.size())  return 0;
    if(memo[i][j] != -1)    return memo[i][j];
    if(a[i] == b[j])    return 1 + dp(i+1,j+1);
    int sum1 = dp(i+1 , j);
    int sum2 = dp(i , j+1);
    return memo[i][j] = max(sum1 , sum2);
}

//////////////////////////////////////////////////////////////////////////////////////////////////

7- (number of coins) : 
**********************

int n = 11 , x;
int a [11] = {5 , 10 , 20 , 50 , 100 , 200 , 500 , 1000 , 2000 , 5000 , 10000};
int memo[nax];
// the length of memo should be the bigest could he give you
int dp(int rem){
    if(rem == 0) return 1;
    if(memo[rem] != -1) return memo[rem];
    int sum = 0;
    for(int i=0;i<n;i++) {
        if(rem >= a[i]) {
            sum = (sum + dp(rem-a[i])) % MOD;
        }
    }
    return memo[rem] = sum;
}

|||||||||||||||||||||||||||||||||||||||||||||| OR ||||||||||||||||||||||||||||||||||||||||||||||||

int n = 11 , x;
int a [11] = {5 , 10 , 20 , 50 , 100 , 200 , 500 , 1000 , 2000 , 5000 , 10000};
int memo[12][30001];
// the length should be the number of coins ans the bigest could he give you
int dp(int i , int rem){
	if(rem == 0)	return 1;

    if(rem < a[i]  ||  i == n)  return 0;

    int &sum = memo[i][rem];
    if(sum  != -1)  return sum;
                // leave it       Take it
    return sum = dp(i+1,rem) + dp(i,rem - a[i]);
}

//////////////////////////////////////////////////////////////////////////////////////////////////

8- (Pearl problem <in 5-th video> ) : 
*************************************

int n , counter[nax] , val[nax];
int memo[1000][1000]; // the size of memo should be (n , the quantinty of each type) 
int dp(int i , int last){
    if(i == n)  return 0;
    int &ret = memo[i][last];
    if(ret != -1)   return ret;
    int sum = 10; //because the problem
    for(int j=last;j<i;j++) 
        sum+=counter[j];          // You can do that by suffix / preffix
    
    ret = dp(i+1,last+1) + sum*val[i]; // Enough Interval

    //add me to hte next interval
    if(i != n-1)
        ret = min(ret , dp(i+1,last));
    
    return ret;
}

|||||||||||||||||||||||||||||||||||||||||||||| OR ||||||||||||||||||||||||||||||||||||||||||||||||

int n , counter[nax] , val[nax];
int memo[1000]; //size of memo is n
int dp(int i){
    if(i == n)  return 0;
    if(memo[i] != -1)   return memo[i];
    int ret = inf  , sum = 0;
    for(int j=i;j<n;j++){
        sum+=counter[j];
        ret = min(ret , (sum+10)*val[j] + dp(j+1));
    }
    return memo[i] = ret;
}

///////////////////////////////////////////////////////////////////////////////////////////////////

9- (Nested Ranges) : 
********************

int n;
int memo[1000][1000]; // (n,n)
int a[nax];
int dp(int i , int j){
    if(j-i+1  <= 2)     //last to numbers (the number on both site)
        return 0;
    if(j-i+1 == 3)  //the last three numbers still
        return a[i]*a[j];
    if(memo[i][j] != -1)
        return memo[i][j];
    int ret = 0;
    for(int k=i+1;k<j;k++){
        ret = max (ret , dp(i,k) + dp(k,j) + a[i]*a[j]);
    }
    return memo[i][j] = ret;
}

//////////////////////////////////////////////////////////////////////////////////////////////////

10- (make string Pilindrom) :
*****************************

int n , memo[1000][1000];  // max length of a 
string  a;
int dp(int i , int j){
    if(i >= j)  return 0;
    if(memo[i][j] != -1)    return memo[i][j];
    int sum1 = 0 , sum2 = 0 , sum3 = 0 ;
    if(a[i] != a[j])
        sum1 = dp(i+1,j-1) + 1;
    else 
        sum1 = dp(i+1,j-1);
    sum2 = dp(i+1,j) + 1;
    sum3 = dp(i,j-1) + 1;
    return memo[i][j] = min({sum1,sum2,sum3});
}

//////////////////////////////////////////////////////////////////////////////////////////////////
11- (counter the numbers of ways that make array plindrom) : 
************************************************************

int n , memo[1000][1000] , a[nax];  // max length of n
int dp(int i , int  j){
    if(i == j)  return 1;
    if(i+1 == j)    return 2 + (a[i] == a[j]);
    int  &ret = memo[i][j];
    if(ret != -1)   return ret;
    
    if(a[i] == a[j])
        ret += dp(i+1,j-1) + 1;
    ret+=dp(i,j-1);
    ret+=dp(i+1,j);
    ret-=dp(i+1,j+1);

    return ret;

//////////////////////////////////////////////////////////////////////////////////////////////////

12- (transform a string to b):
******************************

int n , m , memo[1000][1000];  // max length of a 
string a, b;
int dp(int i , int  j){
    if(i == n)  return m - j;  // if the first string end you must add the remaining of the second to hte answer
    if(j == m)  return n - i;  // if the second string end you must add the remaining of the first to hte answer
    int &ret = memo[i][j];
    if(ret != -1)
        return ret;
    int sum1 = 0 , sum2 = 0 , sum3 = 0;
    if(a[i] == b[j])
        return ret = dp(i+1,j+1);
    sum1 = dp(i+1,j) + 1; // add
    sum2 = dp(i,j+1) + 1;  // remove
    sum3 = dp(i+1,j+1) + 1;  //replace
    return ret = min({sum1,sum2,sum3});
}

//////////////////////////////////////////////////////////////////////////////////////////////////

13- (BitMask):
**************

int setBit(int num , int idx , int value = 1) {return (value) ? (num | (1<<idx) ) : (num &~(1<<idx)) ;}
int getBit(int num , int idx ) {return ((num >> idx) & 1) == 1 ;}
int cntBit(int num){int cntBit(int num){return __builtin_popcount(num);}}

int memo[1<<12];
int dp(int mask){
    int &ret = memo[mask];
    if(ret != -1)   return ret;

    int sum = 0;
    for(int i=0;i<10;i++){
        if(getBit(mask,i)  &&  getBit(mask,i+1)  &&  !getBit(mask,i+2)){
            int sum1 = mask;
            sum1 = setBit(sum1,i,0);
            sum1 = setBit(sum1,i+1,0);
            sum1 = setBit(sum1,i+2,1);
            sum = max(sum,1 + dp(sum1));
        }
        if(!getBit(mask,i)  &&  getBit(mask,i+1)  &&  getBit(mask,i+2)){
            int sum1 = mask;
            sum1 = setBit(sum1,i,1);
            sum1 = setBit(sum1,i+1,0);
            sum1 = setBit(sum1,i+2,0);
            sum = max(sum,1 + dp(sum1));
        }
    }
    return ret = sum;
}


//////////////////////////////////////////////////////////////////////////////////////////////////

14 - (Digit Dp) : 
*****************

#include <iostream>
#include <bits/stdc++.h>
#define ll long long
#define node tuple<int,int>
#define pi 3.14159265359
#define inf 1e9
#define oo 1e18+8
#define log(x , y) log10(y)/log10(x)
#define memset(t , x)  memset(t , x , sizeof t)
#define fill(t , x) fill(t , t+(sizeof t/4) , x)
#define nax (int)(1e6+6)
#define MOD (int)(1e9+7)
#define left 2*i
#define right 2*i+1
#define A(a,n) int a[n];    for(int i=0;i<n;i++)    cin>>a[i];
#define AA(a,n) ll a[n];    for(int i=0;i<n;i++)    cin>>a[i];
#define S(s) string s  ; cin>>s;
#define comma(ans,n)    setprecision(n)<<fixed<<ans<<endl;
#define coutt(x)     printf("%d\n", x);
#define Endl    endl
#define sortt(a)    sort(a.begin(),a.end())
using namespace std;
//#include "debug.cpp"
// Bitmask
int setBit(int num , int idx , int value = 1) {return (value) ? (num | (1<<idx) ) : (num &~(1<<idx)) ;}
int getBit(int num , int idx ) {return ((num >> idx) & 1) == 1 ;}
int cntBit(int num){return __builtin_popcount(num);}

int aa , bb;
string a , b;
int n ;
ll memo[10][3][3];
ll dp(int i , int less , int g){
    if(i == n)  return 0;
    if(memo[i][less][g] != -1)
        return memo[i][less][g];
    ll ret = 0;
    int l = 0 , r = 9;
    if(less == 0)  l = a[i] - '0';
    if(g == 0)  r = b[i] - '0';
    for(int u=l;u<=r;u++){
        ret+= u + dp(i+1,(u > a[i]-'0' ? 1 : less),(u < b[i] - '0' ? 1 : g));
    }
    return memo[i][less][g] = ret;
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    int t = 1;
    while(t){
        cin>>aa>>bb;
        if(aa == -1  &&  bb  == -1)    return 0;
        a = to_string(aa);
        b = to_string(bb);
        cout<<a<<" "<<b<<Endl;
        n = b.size();
        memset(memo,-1);
        reverse(a.begin(),a.end());
        while(b.size() > a.size())
            a.push_back('0');
        reverse(a.begin(),a.end());
        cout<<dp(0,0,0)<<Endl;
    }
    return 0;
}

==========================================================================================================================================================================
                                                                        Segment-Tree
                                                                     -------------------
1- ((Segment Tree)) :
*********************                                                                     
#define left p<<1 , l , (l+r)>>1
#define right p<<1|1 , ((l+r)>>1)+1 , r

vector <int> seg(400100) , a(100100) , lazy(400100);

int build(int p , int l , int r){
    if(l==r) return seg[p] = a[l];
    return seg[p] = (build(left) + build(right)); //to change
}

void push(int p){
    if(!lazy[p]) return;
    seg[p<<1] += lazy[p]; seg[p<<1|1] += lazy[p];
    lazy[p<<1] += lazy[p]; lazy[p<<1|1] +=lazy[p];
    lazy[p] = 0;
    // if(!lazy[p]) return;
    // seg[p<<1] += (lazy[p]*(((l+r)>>1)-l+1)); 
    // seg[p<<1|1] += (lazy[p]*(r-(((l+r)>>1)+1)+1));
    // lazy[p<<1] += lazy[p]; lazy[p<<1|1] +=lazy[p];
    // lazy[p] = 0;
}

int update(int i , int j , int inc , int p , int l , int r){
    if(j<l || r<i) return seg[p];
    if(i<=l && r<=j) return lazy[p] += inc, seg[p] += inc; //to change seg[p] += (inc*(r-l+1));
    push(p);
    return seg[p] = (update(i , j , inc , left) + update(i , j , inc , right)); //to change
}

int query (int i , int j , int p , int l , int r){
    if(j<l  ||  r<i) return 0; // to change
    if(i<=l && r<=j) return seg[p];
    push(p);
    return (query(i , j , left) + query(i , j , right)); //to change
}

//to compress the array
void compress(vector<int> &vec) {
    vector<int> val(vec.begin(), vec.end());
    sort(val.begin(), val.end());
    val.erase(unique(val.begin(), val.end()), val.end());
    for(auto &x:vec) x = lower_bound(val.begin(), val.end(), x) - val.begin();
}


//////////////////////////////////////////////////////////////////////////////////////////////////

Finding subsegments with the maximal sum : 
------------------------------------------

struct Node {
    ll sum, pref, suff, ans;
};

vector <Node> seg(200008);
vector <ll> a(50002);
int n , q;

Node combine(Node l, Node r) {
    Node res;
    res.sum = l.sum + r.sum;
    res.pref = max(l.pref, l.sum + r.pref);
    res.suff = max(r.suff, r.sum + l.suff);
    res.ans = max(max(l.ans, r.ans), l.suff + r.pref);
    return res;
}

Node make_Node(ll val) {
    Node res;
    res.ans = res.pref = res.suff = res.sum = val;
    return res;
}

Node build(int p , int l , int r){
    if(l==r)    return seg[p] = make_Node(a[l]);
    return seg[p] = combine(build(left) , build(right)); //to change
}

Node update(int i , int j , ll inc , int p , int l , int r){
    if(j<l || r<i) return seg[p];
    if(i<=l && r<=j) return seg[p] = make_Node(inc); //to change
    return seg[p] = combine(update(i , j , inc , left) , update(i , j , inc , right)); //to change
}

Node query (int i , int j , int p , int l , int r){
    if(j<l  ||  r<i) return make_Node(-inf); // to change
    if(i<=l && r<=j) return seg[p];
    return combine(query(i , j , left) , query(i , j , right)); //to change
}

//////////////////////////////////////////////////////////////////////////////////////////////////

count the numbers that bigger than val in range : 
-------------------------------------------------

vector <int> seg[30000*4] , a(30000);
int n , q;

void build(int p , int l , int r){
    if(l==r){
        seg[p].push_back(a[l]);
        return;
    }
    build(left);
    build(right);
    // Merge Sort for two sorted array
    seg[p].resize(seg[2*p].size() + seg[2*p+1].size());
    int i = 0 , j = 0 , k = 0;
    while(j < seg[p*2].size() && k < seg[p*2+1].size()){
		if(seg[p*2][j] < seg[p*2+1][k]){
			seg[p][i] = seg[p*2][j];
            i ++ , j ++;
		} 
        else{
			seg[p][i] = seg[p*2+1][k];
		    i ++ , k ++;
		}
	}
	while(j < seg[p*2].size()){
		seg[p][i] = seg[p*2][j];
        i ++ , j ++;
	}
	while(k < seg[p*2+1].size()){
		seg[p][i] = seg[p*2+1][k];
		i ++ , k ++;
	}
}

int query (int i , int j , int p , int l , int r , int val){
    if(j<l  ||  r<i) return 0; // to change
    if(i<=l && r<=j){
        return seg[p].end() - upper_bound(seg[p].begin() , seg[p].end() , val);  // To change
    }
    return (query(i , j , left , val) + query(i , j , right , val)); //to change
}

//////////////////////////////////////////////////////////////////////////////////////////////////

2- ((Sparse-Table)) : 
*********************

// to build and answer the query:
vector<vector<int>> st(20 , vector<int> (100100));
vector<int> a(100100);
int n;

void build(){
    for(int i = 0 ; i < n ; i++) st[0][i] = a[i]; // to change
    for(int j = 1 ; 1<<j <= n ; j++)
        for(int i = 0 ; i+(1<<j) <= n ; i++)
            st[j][i] = temp (st[j-1][i] , st[j-1][i+(1<<j-1)]); // to change
}

int inline get (int l , int r){
    int k = log2(r-l+1);
    return temp (st[k][l] , st[k][r-(1<<k)+1]);  //to change
}


// to build and answer range sum queries with complexity log2(n) :

vector<vector<int>> st(20 , vector<int> (100100));

void build(){
    for(int i = 0 ; i < n ; i++) st[0][i] = a[i];
    for (int j = 1 ; 1<<j <= n ; j++)
        for(int i = 0 ; i+(1<<j) <= n ; i++)
            st[j][i] = st[j-1][i] + st[j-1][i+(1<<j-1)];
}

ll inline get (int l , int r){
    ll sum = 0;
    for(int j = 20 ; j >= 0 ; j--){
        if((1<<j) <= r-l+1){
            sum += st[j][l];
            l += 1<<j;
        }
    }
    return sum;
}

//////////////////////////////////////////////////////////////////////////////////////////////////

3-((2D preffix)) : 
******************
vector<vector<ll>> prefix2d(1100 , vector<ll>(1100)) , a(1000 , vector<ll> (1000));

void generate_prefix(int n , int m){
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            prefix2d[i][j] = a[i][j] + (i - 1 >= 0 ? prefix2d[i-1][j] : 0) + 
                            (j - 1 >= 0 ? prefix2d[i][j-1] : 0) - (i - 1 >= 0  && j - 1 >= 0 ? prefix2d[i-1][j-1] : 0);
}

ll get_prefix(int x1 , int y1 , int x2 , int y2){
    return (prefix2d[x2][y2] - (y1 - 1 >= 0 ? prefix2d[x2][y1-1] : 0) - (x1 - 1 >= 0 ? prefix2d[x1-1][y2] : 0) + (x1 - 1 >= 0  &&  y1 - 1 >= 0 ? prefix2d[x1-1][y1-1] : 0));
}


//////////////////////////////////////////////////////////////////////////////////////////////////

4- ((Fenwick-Tree(BIT))) : 
**************************
// to answer point update and range query
//           range update and point query:

struct FenwickTree {
    vector<int> bit;
    int n;

    FenwickTree(int n) {
        this->n = n;
        bit.assign(n, 0);
    }

    FenwickTree(vector<int> a) : FenwickTree(a.size()) {
        for (size_t i = 0; i < a.size(); i++)
            update(i, a[i]);
    }

    int query(int r) {
        int ret = 0;
        for (; r >= 0; r = (r & (r + 1)) - 1)
            ret += bit[r]; // to change
        return ret;
    }

    int query(int l, int r) {
        return query(r) - query(l - 1);
    }

    void update(int idx, int delta) {
        for (; idx < n; idx = idx | (idx + 1))
            bit[idx] += delta; //to change
    }
    
    void update(int l, int r, int val) {
        update(l, val);
        update(r + 1, -val);
    }
};


// to answer point update and 2d array query:

struct FenwickTree2D {
    vector<vector<int>> bit;
    int n , m;

    FenwickTree2D(int n , int m) {
        this->n = n;
        this->m = m;
        bit.assign(n , vector<int>(m , 0));
    }

    FenwickTree2D(vector<vector<int>> a , int n , int m) : FenwickTree2D(n , m) {
        for (size_t i = 0; i < n; i++)
            for (size_t j = 0; j < m; j++)
                update(i , j , a[i][j]);
    }

    int query(int x, int y) {
        int ret = 0;
        for (int i = x; i >= 0; i = (i & (i + 1)) - 1)
            for (int j = y; j >= 0; j = (j & (j + 1)) - 1)
                ret += bit[i][j];
        return ret;
    }

    void update(int x, int y, int delta) {
        for (int i = x; i < n; i = i | (i + 1))
            for (int j = y; j < m; j = j | (j + 1))
                bit[i][j] += delta;
    }
};

//////////////////////////////////////////////////////////////////////////////////////////////////

5- ((MO's Algorithm))) : 
**************************
int n , q , block_size;
ll ans = 0;
vector <int> a(30010) , mp(nax) , answers(nax);

struct Query {
    int l, r, idx;
    bool operator<(Query other) const
    {
        return make_pair(l / block_size, r) <
               make_pair(other.l / block_size, other.r);
    }
};

void remove(int idx){   // TODO: remove value at idx from data structure
    
}
void add(int idx){      // TODO: add value at idx from data structure
    
}
int get_answer(){  } // TODO: Return the answer value

main : 

        vector <Query> query;
        block_size = (int) sqrt (n + .0) + 1;
        for(int i=0;i<q;i++){
            int l , r;
            cin >> l >> r;
            Query x;
            x.l = l - 1 , x.r = r - 1 , x.idx = i;
            query.push_back(x);
        }
        sort(query.begin(),query.end());
        int cur_l = 0 , cur_r = -1;
        for(auto q : query) {
            while(cur_l > q.l  &&  cur_l >= 0){
                cur_l--;
                add(a[cur_l]);
            }
            while(cur_r < q.r  &&  cur_r < n){
                cur_r++;
                add(a[cur_r]);
            }
            while(cur_l < q.l  &&  cur_l < n){
                remove(a[cur_l]);
                cur_l++;
            }
            while(cur_r > q.r  &&  cur_r >= 0){
                remove(a[cur_r]);
                cur_r--;
            }
            answers[q.idx] = get_answer();
        }
        for(int i=0;i<q;i++)  cout << answers[i] << endl;

==========================================================================================================================================================================

                                                                            Sort    
                                                                        ------------
1 - ((Restaurant Customers)) : 
******************************

int n;
cin>>n;
vector <pair<int,int>> a;
for(int i=0;i<n;i++){
    int x , y;
    cin>>x>>y;
    a.push_back({x,1});
    a.push_back({y,-1});
}
sortt(a);
int counter = 0 , maxi = -inf;
for(int i=0;i<a.size();i++){    
    counter+=a[i].second;
    // cout<<counter<<endl;
    maxi = max(maxi,counter);
}
cout<<maxi<<endl;

//////////////////////////////////////////////////////////////////////////////////////////////////

2 - ((Movie Festival)) :
************************

int n;
cin>>n;
vector <pair<int,int>> a(n);
for(int i=0;i<n;i++)    cin>>a[i].second>>a[i].first;
sortt(a);
int counter = 0 , last = -1;
for(int i=0;i<n;i++){
    if(a[i].second >= last){
        last = a[i].first;
        counter++;
    }
}
cout<<counter<<endl;

//////////////////////////////////////////////////////////////////////////////////////////////////

3 - ((Maximum Subarray Sum)) :
******************************
int n;
cin>>n;
vector <ll> a(n);
for(int i=0;i<n;i++)    cin>>a[i];
ll last = -oo , maxi = -oo;
for(int i=0;i<n;i++){
    last = max(last+a[i],a[i]);
    maxi = max(maxi,last);
}
cout<<maxi<<endl;

//////////////////////////////////////////////////////////////////////////////////////////////////

4 - ((Missing Coin Sum)) :
**************************

int n;
cin>>n;
vector <int> a(n);
for(int i=0;i<n;i++)    cin>>a[i];
sortt(a);
ll counter = 1;
for(int i=0;i<n;i++){
    if(counter < a[i])  break;
    counter+=a[i];
}
cout<<counter<<endl;

//////////////////////////////////////////////////////////////////////////////////////////////////

5 - ((Playlist)) : 
******************
int n;
cin>>n;
vector <int> a(n);
map<int,int> mp;
for(int i=0;i<n;i++)    cin>>a[i];
int counter = 0 , i = 0 , j = 0 , maxi = -inf ;
while(i < n  &&  j < n){
    int x = mp[a[j]];
    if(x == 0){
        counter++;
        mp[a[j]] = 1;
        j++;
    }
    else{
        mp[a[i]] = 0;
        counter--;
        i++;
    }
    maxi = max(maxi,counter);
}
cout<<maxi<<endl;

//////////////////////////////////////////////////////////////////////////////////////////////////

6 - ((Traffic Lights)) :
************************
int n , m;
cin>>n>>m;
vector <int> a(m)  , ans;
for(int i=0;i<m;i++)    cin>>a[i];
set <int> st;
st.insert(0);
st.insert(n);
multiset <int> mp;
mp.insert(n);
for(int i=0;i<m;i++){
    auto it = st.upper_bound(a[i]);
    int r = *it , l = *--it;
    st.insert(a[i]);
    it = mp.find(r-l);
    mp.erase(it);
    mp.insert(r-a[i]);
    mp.insert(a[i]-l);
    ans.push_back(*mp.rbegin());
}
for(auto it : ans)  cout<<it<<" ";
cout<<endl;

//////////////////////////////////////////////////////////////////////////////////////////////////

7 - ((Subarray Sums I)) :                                  slide window algorithm
*************************
int n , k;
cin>>n>>k;
vector <int> a(n);
for(int i=0;i<n;i++)    cin>>a[i];
ll counter = 0 , sum = 0  , i = 0 , j = 0;
sum = a[0];
while(i < n  &&  j < n){
    if(sum > k){
        sum-= a[i];
        i++;
    }
    else if(sum == k){
        sum-=a[i];
        i++;
        counter++;
    }
    else{
        j++;
        sum+=a[j];
    }
}
if(sum == k)    counter++;
cout<<counter<<endl;

//////////////////////////////////////////////////////////////////////////////////////////////////

8 - ((Subarray Sums II)) : 
**************************
int n , k;
cin>>n>>k;
vector <ll> a(n) , pre(n);
ll counter = 0 , sum = 0;
for(int i=0;i<n;i++){
    cin>>a[i];
    sum+=a[i];
    pre[i] = sum;
}
map <ll,int> mp;
mp[0]++;
for(int i=0;i<n;i++){
    counter += mp[pre[i] - k];
    mp[pre[i]]++;
}
cout<<counter<<endl;

==========================================================================================================================================================================

                                                                            Math    
                                                                        ------------
1 - ((Common Divisors)) :   get the gcd for all pair in array and get the maximum
*************************
int n;
cin>>n;
for(int i=0;i<n;i++){
    int x;
    cin>>x;
    a[x]++;
}
for(int i=1000000;i>0;i--){
    int counter = 0;
    for(int j=i;j<=1000000;j+=i)    counter+=a[j];
    if(counter > 1){
        cout<<i<<endl;
        return 0;
    }
}

==========================================================================================================================================================================


                                                                            Hash    
                                                                        ------------
// single HASH:

struct Hash{
	const int p = 1333; // 31 , 53 , 1331 , 1333 , 137
	const int m = 1e9+9; // 1e9+7 , 1e9+9
	vector<ll> pow, h;
	
	void build(string s) {
		int n = s.size();
		pow.resize(n);
		h.resize(n);
		pow[0]=1;
		for(int i=1 ; i<n ; i++) pow[i] = pow[i-1]*p%m;
		h[0]=s[0]-'0'+1;
		for(int i=1 ; i<n ; i++) h[i] = (h[i-1]*p + s[i]-'0'+1)%m;
	}
	
    void add(string s){
        for (int i = 0; i < s.size(); i++) pow.push_back(pow.back()*p%m);
        for (int i = 0; i < s.size(); i++) h.push_back((h.back()*p + s[i]-'0'+1)%m);
    }

	ll getHash(int i, int j) {
		ll ret = h[j];
		if(i) ret -= h[i-1] * pow[j-i+1];
		return (ret%m + m)%m;
	}
};


// double HASH:

struct DoubleHash{
	const int p1=1333, p2=137; // 53, 1331 , 137
	const int m1=1e9+9, m2=1e9+7; // 1e9+7
	vector<ll> pow1, pow2, h1, h2;

	void build(string s) {
		int n = s.size();

		pow1.resize(n);
		h1.resize(n);
		pow1[0]=1;
		for(int i=1 ; i<n ; i++) pow1[i] = pow1[i-1]*p1%m1;
		h1[0]=s[0]-'a'+1;
		for(int i=1 ; i<n ; i++) h1[i] = (h1[i-1]*p1 + s[i]-'a'+1)%m1;

		pow2.resize(n);
		h2.resize(n);
		pow2[0]=1;
		for(int i=1 ; i<n ; i++) pow2[i] = pow2[i-1]*p2%m2;
		h2[0]=s[0]-'a'+1;
		for(int i=1 ; i<n ; i++) h2[i] = (h2[i-1]*p2 + s[i]-'a'+1)%m2;
	}
	
	pair<int, int> getHash(int i, int j){
		ll a = h1[j];
		if(i) a -= h1[i-1] * pow1[j-i+1];
		a = (a%m1 + m1)%m1;

		ll b = h2[j];
		if(i) b -= h2[i-1] * pow2[j-i+1];
		b = (b%m2 + m2)%m2;

		return make_pair(a,b);
	}
};


==========================================================================================================================================================================


                                                                            Trie    
                                                                        ------------

struct no {
    no* nxt[26] = {nullptr};
    int cnt = 0;
};

void add(no* & cur , int i , string& s ,  int n)
{
    if(cur == nullptr) cur = new no;

    if(i == n)
    {
        (cur -> cnt)++;
        return;
    }
    int edge = s[i] - 'a';
    add(cur->nxt[edge] , i+1 , s , n);
}

bool search(no* cur , int i , string& s , int n)
{
    if(cur == nullptr) return false;

    if(i == n)
    {
        if(cur -> cnt >= 1) return true;
        return false;
    }
    int edge = s[i] - 'a';
    search(cur->nxt[edge] , i+1 , s , n);
}

// string s is for sure stored in the tree,
// if it could not be stored then search for it first
void del(no* & cur , int i , string& s , int n)
{
    if(i == n)
    {
        (cur -> cnt)--;
    }
    else
    {
        int edge = s[i] - 'a';
        del(cur->nxt[edge] , i+1 , s , n);
    }

    bool noEdges = true;
    for(int i = 0;i < 26; i++) if(cur->nxt[i] != nullptr) {noEdges = false; break;}

    if(noEdges && (cur -> cnt) == 0)
    {
        delete cur;
        cur = nullptr;
    }
}


//////////////////////////////////////////////////////////////////////////////////////////////////


const int MAX_CHAR = 26;

struct trie {
	trie* child[MAX_CHAR];
	bool isLeaf;

	trie() {
		memset(child, 0, sizeof(child));
		isLeaf = 0;
	}

	void insert(char *str) {
		if(*str == '\0')
			isLeaf = 1;
		else {
			int cur = *str - 'a';
			if(child[cur] == 0 )
				child[cur] = new trie();
			child[cur]->insert(str+1);
		}
	}

	bool wordExist(char* str) {
		if(*str == '\0')
			return isLeaf;

		int cur = *str - 'a';
		if(child[cur] == 0 )
			return false;	// such path don't exist

		return child[cur]->wordExist(str+1);
	}

	bool prefixExist(char* str) {
		if(*str == '\0')
			return true;

		int cur = *str - 'a';
		if(child[cur] == 0 )
			return false;	// such path don't exist

		return child[cur]->prefixExist(str+1);
	}
};

main():
    trie root;

//////////////////////////////////////////////////////////////////////////////////////////////////

struct node{
	int nxt[26];
	bool end;
	node(){
		end = 0;
		memset(nxt,-1,sizeof nxt);
	}
};
node v[1000000];
int cnt = 1;
 
void insert(string p){
	int cur = 0;
	for (int i = 0; i < p.size(); ++i){
		if(v[cur].nxt[p[i]-'a'] == -1){
			v[cur].nxt[p[i]-'a'] = ++cnt;
		}
		cur = v[cur].nxt[p[i]-'a'];
	}
	v[cur].end = 1;
}
bool search(string p){
	int cur = 0;
	for (int i = 0; i < p.size(); ++i){
		if(v[cur].nxt[p[i]-'a'] == -1)
			return false;
		cur = v[cur].nxt[p[i]-'a'];
	}
	return v[cur].end;
}



VasiliysMultiset : Problem
==========================================================================================================================================================================


                                                                        Suffix array    
                                                                    --------------------
(n * (log n)^2 ) :
******************
const int MAXLENGTH = 5000;

char str[MAXLENGTH + 1];        //the string we are building its suffix array
int suf[MAXLENGTH + 1];         //the sorted array of suffix indices
int group[MAXLENGTH + 1];       //In ith iteration: what is the group of the suffix index
int tempGroup[MAXLENGTH + 1];    //temp array to build grouping of ith iteration

//compare to suffixes on the first 2h chars
struct comp{
    int h;
    comp(int h) : h(h) {}

    bool operator()(int i, int j) {
        if (group[i] != group[j])     // previous h-groups are different
        return group[i] < group[j];
        return group[i + h] < group[j + h];
    }
};

void print_suffix(int n) {
    for (int i = 0; i < n; i++) {
        for (int j = suf[i]; j < n - 1; ++j)  // n-1 is string length NOT n
            cout << str[j];
        cout << "\t" << suf[i] << "\n";
    }
    cout << "\n";
}

void buildSuffixArray() {
    int n;      //number of suffixes = 1 + len
    //Initially assume that the group index is the ASCII
    for (n = 0; n - 1 < 0 || str[n - 1]; n++)
        suf[n] = n, group[n] = str[n];  //code of the first char in the suffix

    sort(suf, suf + n, comp(0));        //sort the array the suf on the first char only
    tempGroup[0] = tempGroup[n - 1] = 0;

    //loop until the number of groups=number of suffixes
    for (int h = 1; tempGroup[n - 1] != n - 1; h <<= 1) {
        sort(suf, suf + n, comp(h));        //sort the array using the first 2h chars

        for (int i = 1; i < n; i++)         //compute the 2h group data given h group data
        tempGroup[i] = tempGroup[i - 1] + comp(h)(suf[i - 1], suf[i]);

        for (int i = 0; i < n; i++)         //copy the computed groups to the group array
        group[suf[i]] = tempGroup[i];


    }
    print_suffix(n);  // For print
}

//////////////////////////////////////////////////////////////////////////////////////////////////

(n * log n) : 
**************

const int MAXLENGTH = 2 * 100 * 1000 + 9;
char str[MAXLENGTH + 1];            //the string we are building its suffix array
int suf[MAXLENGTH + 1];             // the sorted array of suffix indices
int group[MAXLENGTH + 1];           //In ith iteration: what is the group of the suffix index
int sorGroup[MAXLENGTH + 1 < 128 ? 128 : MAXLENGTH + 1];    //temp array to build grouping of ith iteration

int groupStart[MAXLENGTH + 1];      //the start index in the sorted array of the current group
int newSuf[MAXLENGTH + 1];          //temp array to store in it the new sorted array
int n;                              //number of suffixes

void print_suffix(int suf_pos) {
    for (int j = suf_pos; j < n - 1; ++j)  // n-1 is string length NOT n
        cout << str[j];
}

void buildSuffixArray() {

    n = 0;
    memset(sorGroup, -1, (sizeof sorGroup[0]) * 128);

    //bucket sort on the first char of suffix
    for (n = 0; n - 1 < 0 || str[n - 1]; n++)
        //treat sorGroup as head of linked list and newSuf as next
        newSuf[n] = sorGroup[str[n]], sorGroup[str[n]] = n;

    int numGroup = -1, j = 0;
    for (int i = 0; i < 128; i++) {
        //compute the groups and groupStart and starting suf
        if (sorGroup[i] != -1) {
            groupStart[++numGroup] = j;
            int cur = sorGroup[i];  // cur = head

            while (cur != -1) {
                suf[j++] = cur;
                group[cur] = numGroup;
                cur = newSuf[cur];  // cur->next
            }
        }
    }

    sorGroup[0] = sorGroup[n - 1] = 0;        //assume that the first group index 0 for next iteration;
    newSuf[0] = suf[0];                       //put the empty suffix to be the smallest suffix

    //loop until the number of groups=number of suffixes
    for (int h = 1; sorGroup[n - 1] != n - 1; h <<= 1) {
        if (true) {  // For print
            for (int i = 0; i < n; i++) {
                print_suffix(suf[i]);

                cout << "\t" << suf[i] << "\t" << group[suf[i]] << "\t" << groupStart[group[suf[i]]] << "\n";
            }
            cout << "\n";
        }
        for (int i = 0; i < n; i++) {   //sort using 2h in the array newSuf
            int j = suf[i] - h;
            if (j < 0)
                continue;
            newSuf[groupStart[group[j]]++] = j;
        }
        for (int i = 1; i < n; i++) {  //compute the 2h group data given h group data
            bool newgroup = group[newSuf[i - 1]] < group[newSuf[i]] || (group[newSuf[i - 1]] == group[newSuf[i]] && group[newSuf[i - 1] + h] < group[newSuf[i] + h]);

            sorGroup[i] = sorGroup[i - 1] + newgroup;
            if (newgroup)
                groupStart[sorGroup[i]] = i;
        }
        for (int i = 0; i < n; i++) {  //copy the data
            suf[i] = newSuf[i];
            group[suf[i]] = sorGroup[i];
        }
    }
}


==========================================================================================================================================================================


                                                                        DP on Tree    
                                                                    ------------------

int n;
vector <ll> l(100100) , r(100100) , a[100100];
ll dp[100100][3];

void dfs(int u , int par){

    for(auto v : a[u]){
        if(v == par)    continue;
        dfs(v,u);
    }

    for(auto v : a[u]){
        if(v == par)    continue;
        dp[u][0] += max(abs(l[u] - l[v]) + dp[v][0] , abs(l[u] - r[v]) + dp[v][1]);
        dp[u][1] += max(abs(r[u] - l[v]) + dp[v][0] , abs(r[u] - r[v]) + dp[v][1]);
    }
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    int t = 1;
    cin>>t;
    while(t--){
        cin >> n;
        for(int i=0;i<=n;i++){
            dp[i][0] = 0;
            dp[i][1] = 0;
            a[i].clear();
        }
        for(int i=1;i<=n;i++)    cin >> l[i] >> r[i];
        for(int i=1;i<n;i++){
            int x , y;
            cin >> x >> y;
            a[x].push_back(y);
            a[y].push_back(x);
        }
        dfs(1,0);
        ll ans = max(dp[1][0],dp[1][1]);
        cout << ans << endl;
        line;
    }
    return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////

((Tree Diameter)) : 
*********************

int n , ans = 0;
vector <int> a[nax];
int dp[200100][3];

bool isLeaf(int u){
    if(u != 1  &&  a[u].size() == 1)    return true;
    return false;
}

void dfs(int u , int par){
    vector <int> temp;

    //  Base Case
    if(isLeaf(u)){
        dp[u][0] = dp[u][1] = 0;
        return;
    }

    // Itreate
    for(auto v : a[u]){
        if(v == par)    continue;
        dfs(v,u);
        temp.push_back(dp[v][0]);
    }

    // Recerence
    sort(temp.begin() , temp.end() , greater <int> ());
    if(temp.size() == 1){
        dp[u][0] = 1 + temp[0];
        dp[u][1] = 0;
    }
    else{
        dp[u][0] = 1 + temp[0];
        dp[u][1] = 2 + temp[0] + temp[1];
    }

    ans = max({ans , dp[u][0] , dp[u][1]});
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    int t = 1;
    // cin>>t;
    while(t--){
        cin >> n;
        if(n == 1){
            cout << 0 << endl;
            line;
            continue;
        }
        for(int i=1;i<n;i++){
            int x , y;
            cin >> x >> y;
            a[x].push_back(y);
            a[y].push_back(x);
        }
        dfs(1,0);
        cout << ans << endl;
        line;
    }
    return 0;
}
