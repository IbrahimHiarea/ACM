                                                                        Math
                                                                     ----------
(( GCD & LCM )):
****************
   1- if  a=0  ==>  GCD(a.b) = 0

   2- Euclid's : if we want the gcd of (a , b) and we can write a/b = c , a%b = d then GCD(a,b) = GCD(b,d)  and the O(max(a,b))
      code : int GCD(int a , int b){
            if(b == 0)  return a;
            else  return GCD(b,a%b);
      }
   
   3- gcd function with O(min(a,b));
   code : int gcd(int a , int b){
         int mini = min(a,b) , ans;
         for(int i=mini;i>0;i--){
            if(a%i == 0  &&  b%i == 0){
               ans = i ;
               return ans;
            }
         }
   }

   4- GCD(m.a,m.b) = m * GCD(a,b)
   5- GCD(a/m,b/m) = GCD(a,b)/m
   6- GCD(a,b) * LCM(a,b) = a * b
   7- GCD(0,0) = 0 = LCM(0,0)
   8- GCD(a,b,c) = GCD(a,GCD(b,c))
   9- if GCD(a,m) = 1   ==> GCD(m,a*b) = GCD(m,b)
   10- GCD(a,b) = d  ==> GCD(a/d,b/d) = 1
   11- GCD(a,b) = GCD(b,a%b)
   12- GCD(a,a+1) = 1
   13- Find three distinct positive integers a, b, c such that a+b+c=n and gcd(a,b)=c, where gcd(x,y)
      ll n ;
        cin>>n;
        if(n%2 == 0){
            cout<<n-3<<" "<<2<<" "<<1<<Endl;
        }
        else{
            for(ll i=2;i<n/2;i++){
                if(__gcd(n-i-1,i) == 1){
                    cout<<n-i-1<<" "<<i<<" "<<1<<endl;
                    break;
                }
            }
        }
///////////////////////////////////////////////////////////////////////////////////////////////////

(( Prime )):
************
1- sieve : 
   int isPrime[1000001];
   void sieve(){
      for(int i=1; i<=1000000; i++){
         isPrime[i]=1;
      }
      isPrime[1]=0;
      for(int i=1; i<=1000; i++){
         if(isPrime[i]==1){
            for(int j=i*i; j<=1000000; j+=i)
               isPrime[j]=0;
         }
      }
   }
2- Nive Approach : O(n)
   void checkPrime(int n){
      int count = 0 ;
      for(int i=1;i<=n;i++)
         if(n%i == 0)   
            count++;
      if(count == 2)
         cout<<"N is prime"<<endl;
      else
         cout<<"N is no't Prime"<<endl;
   }

3- Nive Approach : O(sqrt(n))
   void checkPrime(int n){
      int count = 0 ;
      for(int i=1;i*i<=n;i++){
         if(n%i == 0){
            if(i*i == n)   count++;
            else           count+=2;
         }
      }
      if(count == 2)
         cout<<"N is prime"<<endl;
      else
         cout<<"N is no't Prime"<<endl;
   }

///////////////////////////////////////////////////////////////////////////////////////////////////

(( modulo )) : 
**************
         *               *
   1- (a + b)%c  =  (a%c + b%c)%c
   2- ll MOD = 1e9 + 7;
      ll bigMod(ll x,ll y){
         if (y == 0)return 1;
         if (y == 1)return x;
         ll res = bigMod(x , y / 2LL);
         res *= res;
         res %= MOD;
         if (y % 2){
            res *= x;
            res %= MOD;
         }
         return res;
      }

///////////////////////////////////////////////////////////////////////////////////////////////////

(( Factorial )) :
*****************
   1- Factorial : O(n)
      int factorial(int n){
         return (n == 1 || n == 0) ? 1 : n * factorial(n - 1);
      }

   2- Prime Factorial :
      void primeFactorial(int n){
         while(n%2 == 0){
            n/2;
         }
         for(int i=3;i<sqrt(n);i+=2){
            while(n%i == 0){
               cout<<i<<" ";
               n/=i;
            }
         }
         if(n > 2)   cout<<n;
      }

==========================================================================================================================================================================

                                                                           Graph
                                                                        ----------
(( DFS )) : 
***********
   int vis[nax];
   void dfs(int u) {
      vis[u] = 1;
      for(auto v:adj[u]) {
         if(!vis[v]) {
            dfs(v);
         }
      }
   }

///////////////////////////////////////////////////////////////////////////////////////////////////

(( BFS )) :
***********
   int D[nax];
   void bfs(int src) {
      for(int i=0 ; i<n ; i++) D[i] = inf;
      queue<int> q;
      q.push(src); D[src]=0;
      while(!q.empty()) {
         int u = q.front();
         q.pop();
         for(auto v:adj[u]) {
            if(D[v] == inf) {
               D[v] = D[u] + 1;
               q.push(v);
            }
         }
      }
   }

///////////////////////////////////////////////////////////////////////////////////////////////////

(( Dijkstra )) :
****************

   int D[nax];
   void dijkstra(int src){
      priority_queue<node, vector<node>, greater<node>> q;
      fill(D, D+n, inf);
      D[src]=0; q.push({0, src});
      while(!q.empty()) {
         auto [d, u] = q.top(); q.pop();
         if(d > D[u]) continue;
         for(auto [v, w] : adj[u]) {
            if(D[v] > D[u]+w) {
               D[v] = D[u]+w;
               q.push({D[v], v});
            }
         }
      }
   }

==========================================================================================================================================================================

                                                                        Tree
                                                                     ----------
(( DFS )) :
***********
   void dfs(int u, int parent) {
      for(auto v:adj[u]) {
         if(v != parent) {
            dfs(v, u);
         }
      }
   }

///////////////////////////////////////////////////////////////////////////////////////////////////

(( Find the Depth of each node )) : 
***********************************
   int depth[N];
   void dfs(int u, int parent, int d) {
      depth[u] = d;
      for(auto v:adj[u]) {
         if(v != parent) {
            dfs(v, u, d+1);
         }
      }
   }

///////////////////////////////////////////////////////////////////////////////////////////////////

(( Find the size of each sub-tree )) :
**************************************
   int subTreeSize[N];
   int dfs(int u, int parent) {
      subTreeSize[u] = 1; // initially, there's only u
      for(auto v:adj[u]) {
         if(v != parent) {
            int s = dfs(v, u);
            subTreeSize[u] += s;
         }
      }
      return subTreeSize[u];
   }

///////////////////////////////////////////////////////////////////////////////////////////////////

(( Finding the diameter of the tree )) :
****************************************
   int diameter = 0;
   int dfs(int u, int parent) {
      int mx1 = 0;
      int mx2 = 0;
      for(auto v:adj[u]) {
         if(v != parent) { // if it's not the edge we come from
            int h = dfs(v, u) + 1;
            // maintain the two maximum heights
            if(h > mx2) mx2 = h;
            if(mx2 > mx1) swap(mx1, mx2);
         }
      }
      diameter = max(diameter, mx1+mx2);
      return mx1; // return the max height
   }

==========================================================================================================================================================================

                                                                        DP
                                                                     --------
1- ( Max sum in Grid ) : 
************************
int n , m ;
int memo[1000][1000] , a[1000][1000];
int DP(int i , int j){
    if(i == n-1  &&  j == m-1)  return a[i][j];
    if(i >= n  ||  j >= m)  return 0;
    if(memo[i][j] != -1)    return memo[i][j];
    int sum1 = DP(i+1,j);
    int sum2 = DP(i,j+1);
    return memo[i][j] = max(sum1,sum2) + a[i][j];
}

///////////////////////////////////////////////////////////////////////////////////////////////////

2- (RGB Houses) : 
*****************
int n ;
vector <int> r , b , g;
int memo[nax][4];
int dp(int i , int color){
    if(i == n)  return 0;
    if(memo[i][color] != -1)  return memo[i][color];
    int sum1 = inf , sum2 = inf , sum3 = inf;
    if(color == 0){
        sum2 = dp(i+1,1) + b[i];
        sum3 = dp(i+1,2) + g[i];
    }
    else if(color == 1){
        sum1 = dp(i+1,0) + r[i];
        sum3 = dp(i+1,2) + g[i];
    }
    else if(color == 2){
        sum1 = dp(i+1,0) + r[i];
        sum2 = dp(i+1,1) + b[i];
    }
    else {
        sum1 = dp(i+1,0) + r[i];
        sum2 = dp(i+1,1) + b[i];
        sum3 = dp(i+1,2) + g[i];
    }
    return memo[i][color] = min({sum1 , sum2 , sum3});
}


||||||||||||||||||||||||||||||||||||||||||||||| OR |||||||||||||||||||||||||||||||||||||||||||||||||

if(i == n)  return 0;
if(memo[i][color] != -1)  return memo[i][color];
int sum1=inf;
if(color != 0)  sum1 = min (sum1 , r[i] + dp(i+1,0));
if(color != 1)  sum1 = min (sum1 , b[i] + dp(i+1,1));
if(color != 2)  sum1 = min (sum1 , g[i] + dp(i+1,2));    
return memo[i][color] = sum1;

///////////////////////////////////////////////////////////////////////////////////////////////////

3- (Maximal Product) : 
**********************

ll n , m , k;
ll memo[25][102];
ll dp(ll x , ll rem){
    if(x == k){
        if(rem == 0)
            return 1;
        return 0;
    }
    if(rem == 0)    return 0;
    if(memo[x][rem] != -1)   return memo[x][rem];

    ll ans = 0;
    for(int i=1;i<=rem;i++){
        ll sum = i * dp(x+1,rem - i);
        ans = max(ans , sum);
    }
    return memo[x][rem] = ans ;
}

//////////////////////////////////////////////////////////////////////////////////////////////////

4- (number of Elements of increasing subset) :
**********************************************

int n ;
//  if the vale of a[i] small we work by value
// int memo[n][max_number_could_be]

// if the number of elements is small (n is small) we work by index
//  int memo[n+10][n+10];

int memo[100][100];
vector <int> a;
// prev could be index of last number that you did take |OR| could be the number that you did take .
int dp (int i , int  prev){
    if(i == n)  return 0;
    if(memo[i][prev] != -1) return memo[i][prev];
    int sum1 = 0 , sum2 = 0;
    if(a[i] >= prev)     sum1 = dp(i+1,a[i]) + 1;  //  Take if
    sum2 = dp(i+1,prev);                          //  Leave
    return memo[i][prev] = max(sum1,sum2);
}

//////////////////////////////////////////////////////////////////////////////////////////////////

5- (0/1 Knapsack) : 
*******************

int n , Max ;
vector <int> w , b;
int memo[1000][1000];
int dp(int i , int rem){
    //  to type : 1- if he ask you to make the rem == 0 , you must check if the rem == 0 or return -inf
    //            2- he didn't say to make rem == 0 so leave it 
    if(i == n)  return 0;
    if(memo[i][rem] != -1)  return memo[i][rem];
    int sum1 = 0 , sum2 = 0;
    if(w[i] <=  rem)    sum1 = dp(i+1,rem - w[i]) + b[i];  // take if
    sum2 = dp(i+1,rem);                                    // Leave
    return memo[i][rem] = max(sum1 , sum2);
}

//////////////////////////////////////////////////////////////////////////////////////////////////

6- (longest common subsets (take from any where (not order)) : 
**************************************************************

string a, b ;
int memo[1000][1000];
// it supose to has the lenght of a , b
int dp(int i , int j){
    if(i == a.size()  ||  j == b.size())  return 0;
    if(memo[i][j] != -1)    return memo[i][j];
    if(a[i] == b[j])    return 1 + dp(i+1,j+1);
    int sum1 = dp(i+1 , j);
    int sum2 = dp(i , j+1);
    return memo[i][j] = max(sum1 , sum2);
}

//////////////////////////////////////////////////////////////////////////////////////////////////

7- (number of coins) : 
**********************

int n = 11 , x;
int a [11] = {5 , 10 , 20 , 50 , 100 , 200 , 500 , 1000 , 2000 , 5000 , 10000};
int memo[nax];
// the length of memo should be the bigest could he give you
int dp(int rem){
    if(rem == 0) return 1;
    if(memo[rem] != -1) return memo[rem];
    int sum = 0;
    for(int i=0;i<n;i++) {
        if(rem >= a[i]) {
            sum = (sum + dp(rem-a[i])) % MOD;
        }
    }
    return memo[rem] = sum;
}

|||||||||||||||||||||||||||||||||||||||||||||| OR ||||||||||||||||||||||||||||||||||||||||||||||||

int n = 11 , x;
int a [11] = {5 , 10 , 20 , 50 , 100 , 200 , 500 , 1000 , 2000 , 5000 , 10000};
int memo[12][30001];
// the length should be the number of coins ans the bigest could he give you
int dp(int i , int rem){
	if(rem == 0)	return 1;

    if(rem < a[i]  ||  i == n)  return 0;

    int &sum = memo[i][rem];
    if(sum  != -1)  return sum;
                // leave it       Take it
    return sum = dp(i+1,rem) + dp(i,rem - a[i]);
}

//////////////////////////////////////////////////////////////////////////////////////////////////

8- (Pearl problem <in 5-th video> ) : 
*************************************

int n , counter[nax] , val[nax];
int memo[1000][1000]; // the size of memo should be (n , the quantinty of each type) 
int dp(int i , int last){
    if(i == n)  return 0;
    int &ret = memo[i][last];
    if(ret != -1)   return ret;
    int sum = 10; //because the problem
    for(int j=last;j<i;j++) 
        sum+=counter[j];          // You can do that by suffix / preffix
    
    ret = dp(i+1,last+1) + sum*val[i]; // Enough Interval

    //add me to hte next interval
    if(i != n-1)
        ret = min(ret , dp(i+1,last));
    
    return ret;
}

|||||||||||||||||||||||||||||||||||||||||||||| OR ||||||||||||||||||||||||||||||||||||||||||||||||

int n , counter[nax] , val[nax];
int memo[1000]; //size of memo is n
int dp(int i){
    if(i == n)  return 0;
    if(memo[i] != -1)   return memo[i];
    int ret = inf  , sum = 0;
    for(int j=i;j<n;j++){
        sum+=counter[j];
        ret = min(ret , (sum+10)*val[j] + dp(j+1));
    }
    return memo[i] = ret;
}

///////////////////////////////////////////////////////////////////////////////////////////////////

9- (Nested Ranges) : 
********************

int n;
int memo[1000][1000]; // (n,n)
int a[nax];
int dp(int i , int j){
    if(j-i+1  <= 2)     //last to numbers (the number on both site)
        return 0;
    if(j-i+1 == 3)  //the last three numbers still
        return a[i]*a[j];
    if(memo[i][j] != -1)
        return memo[i][j];
    int ret = 0;
    for(int k=i+1;k<j;k++){
        ret = max (ret , dp(i,k) + dp(k,j) + a[i]*a[j]);
    }
    return memo[i][j] = ret;
}

//////////////////////////////////////////////////////////////////////////////////////////////////

10- (make string Pilindrom) :
*****************************

int n , memo[1000][1000];  // max length of a 
string  a;
int dp(int i , int j){
    if(i >= j)  return 0;
    if(memo[i][j] != -1)    return memo[i][j];
    int sum1 = 0 , sum2 = 0 , sum3 = 0 ;
    if(a[i] != a[j])
        sum1 = dp(i+1,j-1) + 1;
    else 
        sum1 = dp(i+1,j-1);
    sum2 = dp(i+1,j) + 1;
    sum3 = dp(i,j-1) + 1;
    return memo[i][j] = min({sum1,sum2,sum3});
}

//////////////////////////////////////////////////////////////////////////////////////////////////
11- (counter the numbers of ways that make array plindrom) : 
************************************************************

int n , memo[1000][1000] , a[nax];  // max length of n
int dp(int i , int  j){
    if(i == j)  return 1;
    if(i+1 == j)    return 2 + (a[i] == a[j]);
    int  &ret = memo[i][j];
    if(ret != -1)   return ret;
    
    if(a[i] == a[j])
        ret += dp(i+1,j-1) + 1;
    ret+=dp(i,j-1);
    ret+=dp(i+1,j);
    ret-=dp(i+1,j+1);

    return ret;

//////////////////////////////////////////////////////////////////////////////////////////////////

12- (transform a string to b):
******************************

int n , m , memo[1000][1000];  // max length of a 
string a, b;
int dp(int i , int  j){
    if(i == n)  return m - j;  // if the first string end you must add the remaining of the second to hte answer
    if(j == m)  return n - i;  // if the second string end you must add the remaining of the first to hte answer
    int &ret = memo[i][j];
    if(ret != -1)
        return ret;
    int sum1 = 0 , sum2 = 0 , sum3 = 0;
    if(a[i] == b[j])
        return ret = dp(i+1,j+1);
    sum1 = dp(i+1,j) + 1; // add
    sum2 = dp(i,j+1) + 1;  // remove
    sum3 = dp(i+1,j+1) + 1;  //replace
    return ret = min({sum1,sum2,sum3});
}

//////////////////////////////////////////////////////////////////////////////////////////////////

13- (BitMask):
**************

int setBit(int num , int idx , int value = 1) {return (value) ? (num | (1<<idx) ) : (num &~(1<<idx)) ;}
int getBit(int num , int idx ) {return ((num >> idx) & 1) == 1 ;}
int cntBit(int num){int cntBit(int num){return __builtin_popcount(num);}}

int memo[1<<12];
int dp(int mask){
    int &ret = memo[mask];
    if(ret != -1)   return ret;

    int sum = 0;
    for(int i=0;i<10;i++){
        if(getBit(mask,i)  &&  getBit(mask,i+1)  &&  !getBit(mask,i+2)){
            int sum1 = mask;
            sum1 = setBit(sum1,i,0);
            sum1 = setBit(sum1,i+1,0);
            sum1 = setBit(sum1,i+2,1);
            sum = max(sum,1 + dp(sum1));
        }
        if(!getBit(mask,i)  &&  getBit(mask,i+1)  &&  getBit(mask,i+2)){
            int sum1 = mask;
            sum1 = setBit(sum1,i,1);
            sum1 = setBit(sum1,i+1,0);
            sum1 = setBit(sum1,i+2,0);
            sum = max(sum,1 + dp(sum1));
        }
    }
    return ret = sum;
}


//////////////////////////////////////////////////////////////////////////////////////////////////

14 - (Digit Dp) : 
*****************

#include <iostream>
#include <bits/stdc++.h>
#define ll long long
#define node tuple<int,int>
#define pi 3.14159265359
#define inf 1e9
#define oo 1e18+8
#define log(x , y) log10(y)/log10(x)
#define memset(t , x)  memset(t , x , sizeof t)
#define fill(t , x) fill(t , t+(sizeof t/4) , x)
#define nax (int)(1e6+6)
#define MOD (int)(1e9+7)
#define left 2*i
#define right 2*i+1
#define A(a,n) int a[n];    for(int i=0;i<n;i++)    cin>>a[i];
#define AA(a,n) ll a[n];    for(int i=0;i<n;i++)    cin>>a[i];
#define S(s) string s  ; cin>>s;
#define comma(ans,n)    setprecision(n)<<fixed<<ans<<endl;
#define coutt(x)     printf("%d\n", x);
#define Endl    endl
#define sortt(a)    sort(a.begin(),a.end())
using namespace std;
//#include "debug.cpp"
// Bitmask
int setBit(int num , int idx , int value = 1) {return (value) ? (num | (1<<idx) ) : (num &~(1<<idx)) ;}
int getBit(int num , int idx ) {return ((num >> idx) & 1) == 1 ;}
int cntBit(int num){return __builtin_popcount(num);}

int aa , bb;
string a , b;
int n ;
ll memo[10][3][3];
ll dp(int i , int less , int g){
    if(i == n)  return 0;
    if(memo[i][less][g] != -1)
        return memo[i][less][g];
    ll ret = 0;
    int l = 0 , r = 9;
    if(less == 0)  l = a[i] - '0';
    if(g == 0)  r = b[i] - '0';
    for(int u=l;u<=r;u++){
        ret+= u + dp(i+1,(u > a[i]-'0' ? 1 : less),(u < b[i] - '0' ? 1 : g));
    }
    return memo[i][less][g] = ret;
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    int t = 1;
    while(t){
        cin>>aa>>bb;
        if(aa == -1  &&  bb  == -1)    return 0;
        a = to_string(aa);
        b = to_string(bb);
        cout<<a<<" "<<b<<Endl;
        n = b.size();
        memset(memo,-1);
        reverse(a.begin(),a.end());
        while(b.size() > a.size())
            a.push_back('0');
        reverse(a.begin(),a.end());
        cout<<dp(0,0,0)<<Endl;
    }
    return 0;
}

==========================================================================================================================================================================

